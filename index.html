<!DOCTYPE html>
<html>
<head>
  <title>Northeast MX  |  Market Spots - Real Estate & Business</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://www.gstatic.com/charts/loader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/geocodezip/geoxml3@master/polys/geoxml3.js"></script>
<script src="https://unpkg.com/togeojson@0.16.0/dist/togeojson.min.js"></script>
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  
<script src="https://www.gstatic.com/charts/loader.js"></script>
<script>google.charts.load('current',{packages:['corechart']});</script>
<!-- JSZip para leer KMZ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- geoXML3 (funcional desde GitHub raw CDN) -->
<script src="https://cdn.jsdelivr.net/gh/geocodezip/geoxml3@master/polys/geoxml3.js"></script>
  <!-- JSZip para manejar archivos KMZ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- geoXML3 para parsear archivos KML/KMZ -->
<script src="https://cdn.jsdelivr.net/npm/geoxml3@1.0.1/polys/geoxml3.min.js"></script>
<!-- TomTom SDK y Autocompletado -->
  <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.21.0/services/services-web.min.js"defer></script>
  <script src="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.21.0/plugins/SearchBox/SearchBox-web.js"defer></script>
  <link rel="stylesheet" type="text/css" href="https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.21.0/plugins/SearchBox/SearchBox.css"/>
<!-- Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<style>
html, body { height: 100%; margin: 0; padding: 0;}
#map { height: calc(100vh - 60px); width: 100%;}
#filter-panel {
position: fixed; top: -1350px; left: 90px; width: 375px; height: 750px; background: white;
border: 10px solid #ff6600; border-radius: 5px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
transition: top 0.5s ease; z-index: 10; display: flex; flex-direction: column; overflow-y: auto;
}
#filter-panel.open { top: 10px; }
#filter-header { display: flex; justify-content: center; align-items: center; background: #ff6600;
  color: white; padding: 15px; font-weight: bolder; position: relative;font-family: 'Segoe UI', sans-serif;}
#filter-content { padding: 10px; overflow-y: auto; flex-grow: 1; -webkit-overflow-scrolling: touch; touch-action: auto; font-family: 'Segoe UI', sans-serif; font-size: medium;}
#filter-header button { background: none; border: none; color: white; font-size: 20px; cursor: pointer; }
.filter-section.franchises { margin-top: 10px;}
#filter-content { padding: 10px; overflow-y: auto; flex-grow: 1; }
.filter-section {margin-bottom: 10px;}
.dropdown summary { background-color: white; padding: 8px 12px; border-radius: 4px; display: flex; justify-content: flex-start; align-items: center; cursor: pointer; font-size: 12px; font-weight: bold; gap: 6px;}
.dropdown summary span.category-label { color: #ff6600;}
.dropdown summary span.subcategory-label {color: #000000;}
.toggle-btn { display: flex; align-items: center; justify-content: space-between; padding: 4px 10px; border: 1px solid #ccc; border-radius: 4px; margin: 5px 0; cursor: pointer; background: white; color: grey; font-size: 12px;}
.toggle-btn.active { background: #ff6600; color: white; }
#toast { position: fixed; top: 12px; left: 50%; transform: translateX(-50%); background-color: 
  #ff6600; color: white; padding: 10px 20px; border-radius: 6px; font-size: 14px; display: none; 
  z-index: 99999; box-shadow: 0 4px 8px rgba(0,0,0,0.2);font-family: 'Segoe UI', sans-serif;}
  .popup {
  position: fixed;
  top: 65px;
  background-color: white;
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  font-family: 'Segoe UI', sans-serif;
  z-index: 9999;
  width: 600px;
  /* Altura dinámica hasta un máximo de 900px */
  height: auto;
  max-height: 900px;
  overflow-y: auto;
  display: none;
  transition: transform 0.3s ease;
}
#popup {
  left: 20px;
  width: 650px;
  /* elimina o comenta esta línea: */
  /* height: 40px; */
  border: 2px solid #ff6600;
}
#popup.shifted {
  transform: translateX(600px);
}
#popup2 {
  top: 7%;
  right: 1%;
  width: 375px;
  border: 5px solid #ff6600;
  border-radius: 5px;
  transform: translateY(0%);
  /* elimina o comenta esta línea: */
  /* height: 815px; */
  /* en su lugar: */
  height: auto;
  max-height: 80%;
  overflow-y: auto;
  display: none;
}
.popup-header {
  position: sticky;
  top: 0;
  z-index: 10;
  background-color: #ff6600;
  color: white;
  padding: 12px 16px;
  font-size: 14px;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-radius: 0 0 0 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
#popup2 .popup-header { background-color: #ff6600; }
.popup-close {
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  color: white;
  line-height: 1;
  padding-left: 10px;
}
.popup-close:hover { color: #000; }
.popup button { margin-top: 10px; background-color: #ff6600; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 6px; cursor: pointer;}
.popup button:hover { background-color: #ff6600; }
#subcategorychart,  #piechart { width: 100%; height: 200px;}
#franchisechart{ width: 100%; height: 300px;}

.popup-inline-data { margin-bottom: 10px; font-weight: bold;}
.filter-buttons { display: flex; justify-content: space-between; gap: 5px; margin-bottom: 10px;}
.filter-buttons { display: flex; justify-content: center;gap: 10px; margin-bottom: 10px;}
.filter-buttons button { background: #ff6600; color: white; border: none; padding: 6px 10px; font-size: 12px; border-radius: 4px; cursor: pointer; min-width: 90px; text-align: center;}
.filter-buttons button:last-child { background: gray; }
.filter-buttons button:hover { opacity: 0.9; }
.summary-checkbox { margin-left: auto; }
.nse-checkbox-group { display: flex; flex-direction: row; align-items: flex-start; gap: 0px;}
.nse-checkbox-group::-webkit-scrollbar {display: none;}
.nse-checkbox-group label {
white-space: nowrap;
display: flex;
align-items: center;
font-size: 12px;
font-family: 'Segoe UI', sans-serif;
}
.operations-checkbox-group label { font-family: 'Segoe UI', sans-serif; font-size: 12px; color: #333333; margin-bottom: 4px;}
.dropdown summary { padding-left: 0 !important;}
.summary-checkbox { margin: 0 !important;}
.filter-buttons-inline { display: flex; gap: 5px;}
.filter-buttons-inline button { width: 90px;padding: 6px 8px; font-size: 12px; border-radius: 4px; border: none; cursor: pointer; text-align: center;}
.orange-btn { background-color: #ff6600; color: white;}
.gray-btn { background-color: gray; color: white;}
.filter-buttons-inline button { padding: 4px 8px; font-size: 12px; border-radius: 4px; border: none; margin-left: 5px; cursor: pointer;}
.gray-btn { background-color: gray; color: white;}
.filter-section.franchises .filter-buttons-inline button { width: 90px;}
.retail-classification .filter-header-row,.socioeconomic-status .filter-header-row,.avenue-classification .filter-header-row ,.franchises .filter-header-row {
border-top: 2px solid #ccc; padding-top: 25px; padding-bottom: 0px; margin-bottom: 30px; display: flex; align-items: center; justify-content: space-between; font-size: 15px; font-weight: bold; margin: 0; font-family: 'Segoe UI', sans-serif;}
.retail-classification .filter-header-row h3, .socioeconomic-status .filter-header-row h3, .avenue-classification .filter-header-row h3,.location-filter .filter-header-row h3 {
font-size: 12px; font-weight: bold; margin: 0; font-family: 'Segoe UI', sans-serif;
}
.franchises .filter-header-row h3,.retail-classification .filter-header-row h3,.socioeconomic-status .filter-header-row h3,.avenue-classification .filter-header-row h3,.location-filter .filter-header-row h3 {
font-size: 14px; font-weight: bold; margin: 0; font-family: 'Segoe UI', sans-serif;
}
button.layer-active {
  background-color: #d0f0ff;
  border: 2px solid #007bff;
  font-weight: bold;
  font-family: 'Segoe UI', sans-serif;
}
/* Cambia fuente y tamaño SOLO para el contenido del filtro Franchises */
.filter-section.franchises .dropdown,.filter-section.franchises .toggle-btn,.filter-section.franchises summary span,.filter-section.franchises .subcategory-label,.filter-section.franchises .category-label,.filter-section.location-filter .state-label {
font-family: 'Segoe UI', sans-serif; /* Cambia por la fuente que desees */
font-size: 12px !important; /* Cambia por el tamaño deseado */
}
.filter-section.retail-classification label { font-family: 'Segoe UI', sans-serif; font-size: 12px !important; color: #333; margin-bottom: 10px; display: block;}
#operations-control-content,#pin-control-content,#nse-control-content,#location-control-content { padding-top:15px;margin-top: 15px;font-family: 'Segoe UI', sans-serif;}
#operations-control-content label,#pin-control-content label,#nse-control-content label,#location-control-content label { display: block;margin-bottom: 10px;}
.dropdown summary { position: relative; padding-right: 20px;}
/* Por defecto, todas las flechas serán negras */
.dropdown summary::after { content: "►"; position: absolute; right: 10px; font-size: 12px; transition: transform 0.2s ease; color: black; }
/* Cuando están abiertas, cambia el ícono */
.dropdown[open] summary::after { content: "▼"; }
/* Solo las flechas de categorías principales → en naranja */
#pin-control-content > details.dropdown > summary::after { color: #ff6600; }
/* Flecha por defecto para subcategorías (ciudades en Traffic Generators) */
#avenue-control-content details.details-subcategory > summary::after {
content: "►";   /* Flecha derecha */
color: black;   /* Puedes cambiar a #ff6600 si quieres */
}
/* Flecha para subcategorías abiertas */
#avenue-control-content details.details-subcategory[open] > summary::after {
content: "▼";   /* Flecha hacia abajo */
}
/* Flechas de categoría en naranja para Traffic Generators */
#avenue-control-content > details.dropdown > summary::after {color: #ff6600;}
/* Flecha por defecto para subcategorías (cerradas) */
#pin-control-content details.details-subcategory > summary::after { content: "►"; color: black;}
 
/* Flecha para subcategorías abiertas */
#pin-control-content details.details-subcategory[open] > summary::after { content: "▼"; }
#tooltip {
  position: absolute;
  pointer-events: none;
  background: rgba(0,0,0,0.75);
  color: #fff;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  display: none;
  white-space: nowrap;
  transform: translate(-50%, -100%); /* centrado horizontal y encima */
}
html, body {
height: 100%;
margin: 0;
padding: 0;
overflow: hidden; /* 🚫 evita scroll en todo el cuerpo */
}
#map {
height: 100%;
width: 100%;
position: absolute;
top: 0;
left: 0;
}
#dev-toolbar {
  position: fixed;
  top: 10px;
  left: 50%;
  height: 30px;
  display: none;
  align-items: center;
  background-color:#ffffff;
  border: 5px solid #ff6600;
  border-radius: 10px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.12);
  z-index: 1;
  padding: 5px 15px;
  transition: opacity 0.3s, width 0.3s;
}
#dev-toolbar button {
  background: none;
  border: none;
  color: #ff6600;
  font-size: 15px;
  margin: 0 7px;
  cursor: pointer;
  border-radius: 7px;
  transition: 0.15s;
  padding: 5px 7px;
}

#toolbar {
  position: fixed;
  top: 1%;
  left: 1%;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 50px;
  background-color: #ffffff;
  border: 5px solid #ff6600;
  border-radius: 5px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.12);
  z-index: 9999;
  gap: 2px;
  padding: 8px 0;
  transition: opacity 0.3s ease;
  font-size: 14px;
  zoom: 1;
  will-change: transform;
  transform-origin: left center;
}

#toolbar button {
  background: none;
  border: none;
  color: #ff6600;
  font-size: 15px;
  margin: 2px 0;
  cursor: pointer;
  border-radius: 7px;
  transition: 0.15s;
}

#toolbar button:hover, #toolbar button.active-toggle {
  background: #0000;
  font-size: 16px;
}
/* Botón de toggle, siempre visible */
#toolbar-toggle {
  font-size: 15px;
  color: #0000;
  background: #ff6600;
  border-radius: 8px;
  padding: 4px 8px;
}
/* Cuando está minimizada */
.toolbar-hidden {
  background: #0000;
  width: 50px !important;
  opacity: 0.1;
  right: 1%;
  height: 30px;
}
.toolbar-hidden #toolbar-toggle {
  margin: 3px;
  color: #ff6600;
  background: #0000;
}
.toolbar-hidden button:not(#toolbar-toggle) {
  display: none;
  align-items: center;
}
.toolbar-hidden .toolbar-divider {
  display: none !important;
}
/* Estilo uniforme para encabezado y botones de todos los filtros */
.filter-section {margin-bottom: 15px;}
.filter-header-row {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 4px; /* 🔽 menos espacio debajo del título */
padding-bottom: 2px;   /* 🔽 menos espacio interior */
font-family: 'Segoe UI', sans-serif;
}
.filter-header-row h3 {
font-size: 14px;
font-weight: bold;
margin: 0;
font-family: 'Segoe UI', sans-serif;
}
 
.filter-buttons-inline {
display: flex;
gap: 6px;
font-family: 'Segoe UI', sans-serif;
}
.filter-buttons-inline button {
padding: 4px 8px;
font-size: 12px;
border-radius: 4px;
border: none;
cursor: pointer;
min-width: 80px;
text-align: center;
font-family: 'Segoe UI', sans-serif;
}
#pin-control-content,
#operations-control-content,
#avenue-control-content,
#nse-control-content,
#location-control-content {
margin-top: 4px !important;
padding-top: 4px !important;
font-family: 'Segoe UI', sans-serif;
}
.avenues-checkbox-group label {
display: block;
margin-bottom: 10px;
font-family: 'Segoe UI', sans-serif;
font-size: 13px;
color: #333;
}
#autocomplete-container {
display: none; /* oculto al cargar */
position: fixed;
top: 290px; /* ← bajamos un poco más para evitar superposición */
left: 85px;
z-index: 10001; /* 🔼 mayor que la lupa */
width: 390px;
background: #ffffff;
height: 20px;
font-family: 'Segoe UI', sans-serif;
transition: opacity 0.3s ease;
}
#traffic-panel {
  display: none;
  position: fixed;
  top: 70px;
  right: 10px;
  width: 300px;
  max-height: 600px;
  overflow-y: auto;
  background: #ffffff;
  color: #000000;
  border: 8px solid #ff6600;
  border-radius: 8px;
  padding: 10px;
  z-index: 9999;
  font-family: 'Segoe UI', sans-serif;
}
#bottom-image-container {
position: fixed;
bottom: 15px;
left: 50%;
transform: translateX(-50%);
z-index: 99999;
text-align: center;
}
#bottom-image-container img {
max-width: 50px;
height: auto;
display: block;
cursor: pointer;
}
#business-type {
  position: fixed;
  bottom: 100px;
  left: 10%;
  height: 30px;             	/* ← alto deseado */
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  background-color:#ffffff;
  border: 3px solid #ff6600;
  border-radius: 10px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.12);
  z-index: 9999;
  padding: 5px 15px;
  transition: opacity 0.3s, width 0.3s;
}
#city-panel {
  display: none;
  position: fixed;
  top: 70px;
  right: 10px;
  width: 300px;
  max-height: 600px;
  overflow-y: auto;
  background: #ffffff;
  color: #000000;
  border: 8px solid #ff6600;
  border-radius: 8px;
  padding: 10px;
  z-index: 9999;
  font-family: 'Segoe UI', sans-serif;
}
#search-box2 {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 9999;
  background: white;
  padding: 8px;
  border-radius: 6px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}
#poi-search-input {
  width: 450px;
  padding: 6px;
  font-size: 12px;
  
}
#search-button2 {
  padding: 6px 10px;
  font-size: 14px;
  margin-left: 5px;
}
body.dark-mode #toolbar {
  background-color: #666666;
  border-color: #383838;
}
body.dark-mode #dev-toolbar {
  background-color: #666666;
  border-color: #383838;
}
body.dark-mode #toolbar button {
  color: #ffffff;
}
body.dark-mode #filter-panel  {
background-color: #1d1d1d;
border-color: #383838;
color: #ffffff;
}
body.dark-mode #filter-header {
  background-color: #383838;
}
body.dark-mode .orange-btn {
  background-color: #383838;
}
body.dark-mode .dropdown summary {
  background-color: #1d1d1d;
}
body.dark-mode .dropdown summary {
  background-color: #1d1d1d;
}
body.dark-mode .dropdown summary span.category-label{
  color: #ffffff;
}
body.dark-mode .filter-section.retail-classification label {
  color: #ffffff;
}
body.dark-mode .dropdown summary span.subcategory-label {
  color: #ff6600;
}
body.dark-mode #popup2 {
background-color: #1d1d1d;
border-color: #383838;
color: #ffffff;
}
body.dark-mode #popup2 .popup-header {
background-color: #383838;
color: #ffffff;
}
body.dark-mode #pin-control-content details.details-subcategory > summary::after {
color: #ff6600;
}
body.dark-mode #traffic-panel{
background: #1d1d1d;
border-color: #383838;
color: #ffffff
}
body.dark-mode #city-panel{
background: #1d1d1d;
border-color: #383838;
color: #ffffff
}
#export-files-panel{
  display: none;
  position: fixed;
  width: 200px;
  top: 16%;
  left: 5%;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
  flex-direction: column;
  gap: 4px; /* ← reducido */
}
body.dark-mode #export-files-panel{ background: #666666; border-color: #383838; color: #ffffff;}
body.dark-mode #export-research { color: #ffffff;}
body.dark-mode #btnLoadExcel { color: #ffffff;}
#poi-search-box{
  display: none;
  width: 400px;
  height: 20px;
  top: 220px;
  align-items: center;
  gap: 6px;
  position: fixed;
  left: 85px;
  z-index: 5;
  background: #ffffff;
  padding: 8px;
  border: 3px solid #ff6600;
  border-radius: 5px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
body.dark-mode #poi-search-box{ background: #666666; border-color: #383838; color: #ffffff;}
/* Panel de fondo */
#import-files-panel {
  display: none;
  position: fixed;
  width: 200px;
  top: 93px;
  left: 90px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 5px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 12px;
  color: black;
  padding: 10px 10px;
  flex-direction: column;
  gap: 6px;
}
#import-analysis-toggle, #kmz-trigger{ color:#000000}

body.dark-mode #import-files-panel{ background: #666666; border-color: #383838; color: #ffffff;}
body.dark-mode #kmz-trigger { color: #ffffff;}
body.dark-mode #exportKmzBtn { color: #ffffff;}
body.dark-mode #load-kmz-btn { color: #ffffff;}
#draw-tools-panel{
  display: none;
  position: fixed;
  width: 315px;
  top: 325px;
  left: 85px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
  flex-direction: column;
  gap: 4px; /* ← reducido */
}
body.dark-mode #draw-tools-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#ruler-toggle, #circle-toggle, #drawPolygonBtn, #local-pin-toggle { color:#000000}
body.dark-mode #ruler-toggle{ color: #ffffff;}
body.dark-mode #circle-toggle { color: #ffffff;}
body.dark-mode #drawPolygonBtn{ color: #ffffff;}
body.dark-mode #local-pin-toggle {color: #ffffff;}
#city-options-panel{
  display: none;
  position: fixed;
  width: 315px;
  top: 450px;
  left: 85px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
  flex-direction: column;
  gap: 4px; /* ← reducido */
}
body.dark-mode #city-options-panel{ background: #666666; border-color: #383838; color: #ffffff;}
.option-item {
  display: flex;
  align-items: center;
  gap: 6px;           /* separación checkbox ↔️ icono ↔️ texto */
}
.option-item input[type="checkbox"] {
  /* opcional: tamaño más grande */
  width: 12px;
  height: 12px;
}
.option-item label {
  display: flex;
  align-items: center;
  gap: 6px;           /* ajusta si quieres más/menos espacio */
  cursor: pointer;    /* clickeable sobre toda la fila */
  font-size: 12px;
  color: #000000
}
#residential-options-panel{
  display: none;
  position: fixed;
  width: 315px;
  top: 65px;
  left: 740px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
  flex-direction: column;
  gap: 4px; /* ← reducido */
}
body.dark-mode #residential-options-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#retail-options-panel{
  display: none;
  position: fixed;
  width: 250px;
  top: 475px;
  left: 85px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
  flex-direction: column;
  gap: 4px; /* ← reducido */
}
body.dark-mode #retail-options-panel{background: #666666; border-color: #383838; color: #ffffff;}
#research-pin-form{
  display: none;               /* ← ahora es flex */
  position: fixed;
  top: 80px;
  right: 20px;
  background: #ffffff;
  border: 5px solid #ff6600;
  border-radius: 8px;
  width: 160px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 14px 14px;
  gap: 4px; /* ← reducido */
}
body.dark-mode #research-pin-form{ background: #666666; border-color: #383838; color: #ffffff;}
#traffic-options-panel{
  display: none;
  position: fixed;
  width: 315px;
  top: 535px;
  left: 85px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
  flex-direction: column;
  gap: 4px; /* ← reducido */
}
body.dark-mode #traffic-options-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#settings-panel {
  display: none;
  position: fixed;
  width: 125px;
  top: 725px;
  left: 85px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
}
body.dark-mode #settings-panel{ background: #666666; border-color: #383838; color: #ffffff;}
#settings-buttons {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
}
#settings-buttons button {
  background: none;
  border: none;
  cursor: pointer;
}
#portfolio-options-panel{
  display: none;
  position: fixed;
  width: 315px;
  top: 625px;
  left: 85px;
  background: #ffffff;
  border: 3px solid #ff6600;
  border-radius: 8px;
  z-index: 10000;
  font-family: 'Segoe UI', sans-serif;
  font-size: 14px;
  color: #ff6600;
  padding: 8px 10px;
  flex-direction: column;
  gap: 4px; /* ← reducido */
}
#reports-options-panel {
    display: none;
    position: fixed;
    width: 315px;
    top: 620px;
    left: 85px;
    background: #ffffff;
    border: 3px solid #ff6600;
    border-radius: 8px;
    z-index: 10000;
    font-family: 'Segoe UI', sans-serif;
    font-size: 14px;
    color: #ff6600;
    padding: 8px 10px;
    /* Estas propiedades solo aplicarán cuando el panel esté en flex */
    flex-direction: column;
    gap: 4px;
  }
  /* Panel oculto por defecto */
  #notes-panel {
    position: fixed;
    top: 80px;
    right: 10px;
    width: 350px;
    height: 600px;
    background: #fafafa;
    border: 5px solid #383838;
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: none;
    flex-direction: column;
    padding: 20px;
    z-index: 10000;
    overflow-y: auto;
  }
  #notes-header {
    display: flex;
    font-size: medium;
    justify-content: space-between;
    align-items: center;
  }
  #note-input {
    width: 95%;
    height: 150px;
    margin: 10px 0;
    padding: 6px;
    resize: vertical;
  }
  #save-note, #clear-notes {
    cursor: pointer;
    margin-bottom: 8px;
  }
  #notes-list {
    flex: 1;
    overflow-y: auto;
    border-top: 1px solid #383838;
    padding-top: 8px;
  }
  .note-item {
    background: #fff;
    border: 3px solid #1d1d1d;
    border-radius: 4px;
    padding: 6px;
    margin-bottom: 6px;
    position: relative;
    font-family: "Arial", sans-serif;
    font-size:   12px;
  }
  .note-item button {
    position: absolute;
    top: 4px;
    right: 4px;
    background: none;
    border: none;
    cursor: pointer;
  }
/* Pantalla completa de bienvenida */
#start-screen {
  position: fixed;      /* Siempre encima */
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(39, 41, 40, 1);
  display: flex;        /* Para centrar */
  align-items: center;
  justify-content: center;
  z-index: 9999;
  transition: opacity 0.5s ease;
}
/* Opcional: ajustar tamaño del GIF */
#start-screen img {
  max-width: 500px;
  max-height: 500px;
}
#search-input{
top: 10px;
width: 100%;
padding: 13px;
border: 3px solid #ff6600;
background: #ffffff;
border-radius: 4px;
font-size: 13px;
}
body.dark-mode #search-input{ background: #666666; border-color: #383838; color: #ffffff;}
    /* Panel lateral de municipios — oculto por defecto */
    #municipios-panel {
      display: none;              /* ← oculto al inicio */
      position: absolute;
      top: 70px;
      right: 10px;
      width: 265px;
      max-height: 400px;
      overflow-y: auto;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border: 5px solid #ff6600;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      z-index: 100;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    #municipios-panel h3 {
  display: flex;               /* activa flexbox */
  align-items: center;         /* centra verticalmente */
  justify-content: center;     /* centra el título horizontalmente */
  margin: 0 0 8px;
  font-size: 16px;
  height: 35px;
  background: #ff6600;
  position: relative;          /* para posicionar el botón absoluto */
  color: #fff;                 /* opcional: texto blanco */
  padding: 0 35px;             /* deja espacio a izquierda y derecha */
}
#municipios-panel h3 button#municipios-close {
  position: absolute;
  top: 50%;                    /* punto medio vertical del h3 */
  right: 4px;                  /* distancia al borde derecho */
  transform: translateY(-50%); /* ajusta para que el botón quede perfectamente centrado */
  background: transparent;
  border: none;
  font-size: 16px;
  cursor: pointer;
  line-height: 1;
  color: #fff;                 /* igual que el texto, o el que prefieras */
}
    /* Botón de cerrar dentro del panel */
    #municipios-close {
      position: absolute;
      top: 2px;
      right: 2px;
      background: transparent;
      border: none;
      font-size: 16px;
      cursor: pointer;
      line-height: 1;
    }
    #municipios-list label {
      display: block;
      margin-bottom: 10px;
      cursor: pointer;
    }
    #municipios-list input {
      margin-right: 6px;
    }

    #add-property-form {
     display: none;
     position: fixed;
     top: 10%;
     left: 89%;
     transform: translateX(-50%);
     background: #fff;
     padding: 16px;
     border: 2px solid #333;
     border-radius: 8px;
     z-index: 10000;
     font-family: sans-serif;
     width: 300px;
   }
   #add-property-form input {
     width: 100%;
     margin-bottom: 8px;
     padding: 4px;
   }
   #add-property-form button {
     margin-right: 8px;
   }
 #portfolio-popup {
 position: absolute;
 top: 80px;
 right: 10px;
 width: 400px;
 height: 900px;
 background: white;
 border-radius: 8px;
 box-shadow: 0 2px 8px rgba(0,0,0,0.3);
 overflow: hidden;
 z-index: 10000;
}
.gm-style .gm-style-iw-d {
  overflow: visible !important;
  max-height: none   !important;
  max-width:  none   !important;
}




  #loading-screen {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(255,255,255,0.8);
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .loading-content {
    text-align: center;
    font-size: 18px;
    color: #333;
  }

  .spinner {
    margin: 0 auto 10px;
    border: 6px solid #ccc;
    border-top: 6px solid #FF6600;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
  to { transform: rotate(360deg); }
}




</style>
</head>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBimPrRAY6NuxHcucxTpZ5hxW39CDnvnLM&callback=initMap&libraries=drawing,geometry,visualization" async defer></script>
<body>
  <div id="map" style="width:100%; height:100vh;"></div>
  
  <div id="tooltip"></div>
  <!-- //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////-->
  <div id="poi-search-box">
  <input type="text" id="poi-search-input" placeholder="Search for any place..."
    style="padding: 10px; height: 15px; width: 250px; border: 0px solid #FF6600; background: #0000; font-size: 12px; border-radius: 0px; outline: none;">
  <button id="poi-search-button"style="background: none; border: none; font-size: 12px; font-weight: bold; cursor: pointer;">
    Search
  </button>
  <button id="poi-clear-button"
    style="background: none; border: none; font-size: 12px; font-weight: bold; cursor: pointer;">
    Clear
  </button>
</div>

<!-- Nueva barra de herramientas -->
<div id="toolbar" class="toolbar-visible">


  <button id="filter-menu-button" title="Report Selection Menu"onclick="toggleMenu()">
    <img
    id="menu-icon"
    src="images/icons/menu.png"
    style="width:25px; height:25px;"
    />
    </button>    



<button id="save-analysis-toggle" title="Save Analysis">
  <img  id="save-icon" 
        src="images/icons/save.png" 
        style="width:25px; height:25px;"
        />
</button>
<button id="import-analysis-toggle" title="Open MKTS File" onclick="triggerImport()">
  <img  id="import-icon" 
        src="images/icons/open.png" 
        style="width:25px; height:25px;"
        />
</button>
<button id="import-files" title="Google Earth Options">
  <img  id="earth-icon" 
        src="images/icons/earth.png" 
        style="width:25px; height:25px;"
        />
</button>

  
<div class="toolbar-divider" style="width:24px; height:1px; background:#ccc; margin:0 8px;"></div>

<button id="poi-toggle-btn" title="Search Any Place in the Map">
<img
id="poi-icon"
src="images/icons/search.png"
style="width:25px; height:25px;"
/>
</button>



 <button id="activate-p" title="Show/Hide Google Maps Markers">
  <img  id="activate-poi" 
        src="images/icons/poi-on.png" 
        alt="POI ON" 
        style="width: 25px; height: 25px;" 
        />
</button>  



<button id="search-toggle" title="Search Franchise in Database">
  <img
  id="search-icon"
  src="images/icons/database.png"
  style="width:25px; height:25px;"
  />
  </button>



<button id="pin-toggle" title="My Location">
  <img  id="location-icon" 
  src="images/icons/location.png" 
  style="width:25px; height:25px;"
  />
</button>
  
  
<div class="toolbar-divider" style="width:24px; height:1px; background:#ccc; margin:0 8px;"></div>

  <button id="draw-tools" title="Draw Tools">
    <img  id="draw-icon" 
    src="images/icons/draw-tools.png" 
    style="width:25px; height:25px;"
    />
</button>
<button id="circle-toggle" title="Draw a Circle for Analysis">
  <img  id="draw-icon" 
  src="images/icons/circle.png" 
  style="width:25px; height:25px;"
  />
</button>
  

<button id="city-toggle" title="City Limits">
  <img  id="city-toggle" 
        src="images/icons/boundries.png"         
        style="width: 25px; height: 25px;" 
        />
</button>
<button id="city-options" title="City Elements">
  <img  id="city-icon" 
  src="images/icons/city.png" 
  style="width:25px; height:25px;"
  />
</button>
<button id="retail-options" title="Retail Options">
  <img  id="retail-icon" 
  src="images/icons/retail.png" 
  style="width:25px; height:25px;"
  />
</button>
<button id="traffic-options" title="Traffic Options">
  <img  id="traffic-icon" 
  src="images/icons/traffic.png" 
  style="width:25px; height:25px;"
  />
</button>

<button id="reports-options" title="Heatmap">
  <img
    id="reports-icon"
    src="images/icons/heatmap.png"
    style="width:25px; height:25px;"
    alt="Reports"
  />
</button>



<div class="toolbar-divider" style="width:24px; height:1px; background:#ccc; margin:0 8px;"></div>

<button id="notes-toggle" title="Notepad">
  <img  id="notes-icon" 
  src="images/icons/notepad.png" 
  style="width:25px; height:25px;"
  />
</button>

<button id="reset-button" title="Reset All">
  <img  id="reset-icon" 
  src="images/icons/reset.png" 
  style="width:25px; height:25px;"
  />
</button>
<button id="settings" title="Settings">
  <img  id="settings-icon" 
  src="images/icons/settings.png" 
  style="width:25px; height:25px;"
  />
</button>
<button id="toolbar-toggle" title="Show/Hide toolbar" onclick="toggleToolbar()">▲</button></div>
</div>
<!---------------------------------------------------------- Boton de Importar ------------------------------------------------------------------------>
<div id="import-files-panel">
<button id="kmz-trigger" title="Load KMZ Files" style="
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 0;
  width: 100%;
  text-align: left;
">
    <img src="https://static.wixstatic.com/media/805cf6_9e94c6cb1de3464dbc5db7a3d9fa9476~mv2.png" alt="Search" style="width:20px; height:20px;" />
    <span>Open KMZ File</span>
  </button>
  <button id="exportKmzBtn" title="Download Pins & Polygons to KMZ" style="
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
  ">
    <img src="https://static.wixstatic.com/media/805cf6_9e94c6cb1de3464dbc5db7a3d9fa9476~mv2.png" style="width: 20px; height: 20px;" />
    <span>Export to KMZ</span>
  </button>


<input type="file" id="kmz-input" accept=".kmz" style="display: none;" />
</div>

  
<!---------------------------------------------------------- Opciones de Dibujo ------------------------------------------------------------------------>
<div id="draw-tools-panel">
  <button id="local-pin-toggle" title="Add a Custom Marker" onclick="activatePinMode" style="
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 0;
  width: 100%;
  text-align: left;
  ">
  <img src="https://img.icons8.com/?size=48&id=85049&format=png" style="width: 20px; height: 20px;" />
  <span>Add a Custom Marker</span>
  </button>

  <button id="expansion-pin-btn"
        title="Add Expansion Pin"
        style="display:flex;align-items:center;gap:6px;background:none;border:none;cursor:pointer;padding:4px 0;">
  <img src="https://img.icons8.com/?size=48&id=85049&format=png" style="width: 20px; height: 20px;" />
  <span>Expansion Pin</span>
</button>


  <button id="ruler-toggle" title="Point A to B Distance" style="
    display: flex;
    align-items: center;
    gap: 8px; /* ← menos espacio entre ícono y texto */
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
  ">
    <img src="https://img.icons8.com/?size=60&id=78651&format=png" style="width: 20px; height: 20px;" />
    <span>Distance from A to B</span>
  </button>
<button id="drawPolygonBtn" title="Draw a Custom Polygon" style="
display: flex;
align-items: center;
gap: 8px;
background: none;
border: none;
cursor: pointer;
padding: 4px 0;
width: 100%;
text-align: left;
">
<img src="https://img.icons8.com/?size=60&id=78727&format=png" style="width: 20px; height: 20px;" />
<span>Draw a Polygon</span>
</button>
</div>
<!---------------------------------------------------------- City Options------------------------------------------------------------------------>
<div id="city-options-panel">

    <div class="option-item">
    <input type="checkbox" id="opt-airports" />
    <label for="opt-airports">
      <img src="images/icons/airports.png" width="15" height="15" />
      Airports
    </label>
  </div>


  <div class="option-item">
    <input type="checkbox" id="opt-audience" />
    <label for="opt-audience">
      <img src="images/icons/ticket.png" width="20" height="20" />
      Audience & Concerts Venues
    </label>
  </div>



  <div class="option-item">
    <input type="checkbox" id="opt-evcs" />
    <label for="opt-evcs">
      <img src="images/icons/evcs.png" width="20" height="20" />
      Electric Vehicles Charging Stations
    </label>
  </div>




  <div class="option-item">
    <input type="checkbox" id="opt-public-parks" />
    <label for="opt-public-parks">
      <img src="images/icons/park.png" width="20" height="20" />
      Public Parks
    </label>
  </div>


  <div class="option-item">
    <input type="checkbox" id="opt-stadiums" />
    <label for="opt-stadiums">
      <img src="images/icons/stadium.png" width="20" height="20" />
      Sport Stadiums
    </label>
  </div>



  <div class="option-item">
    <input type="checkbox" id="opt-schools" />
    <label for="opt-schools">
      <img src="images/icons/school.png" width="20" height="20" />
      Universities & Highschools
    </label>
  </div>




  <div class="option-item">
    <input type="checkbox" id="opt-urbantrain" />
    <label for="opt-urbantrain">
      <img src="images/icons/train.png" width="20" height="20" />
      Urban Train Stations
    </label>
  </div>


</div>
<!---------------------------------------------------------- Retail Options------------------------------------------------------------------------>
<div id="retail-options-panel">
  <button id="toggle-all-properties" style="margin-bottom:8px;">
    Show/Hide
  </button>
  <div style="display:flex; flex-direction:column; gap:4px;">
    <label>
      <input type="checkbox" id="toggle-locales-renta" data-cat="localesRenta" />
      Retail Spaces Rent
    </label>
    <label>
      <input type="checkbox" id="toggle-locales-venta" data-cat="localesVenta" />
      Retail Spaces Sale
    </label>
    <label>
      <input type="checkbox" id="toggle-terrenos-renta" data-cat="terrenosRenta" />
      Land Lot Rent
    </label>
    <label>
      <input type="checkbox" id="toggle-terrenos-venta" data-cat="terrenosVenta" />
      Land Lot Sale
    </label> 
  </div>
  </div>
<!---------------------------------------------------------- Traffic Options------------------------------------------------------------------------>
<div id="traffic-options-panel">
  <button id="traffic-toggle" title="Shopping Malls" style="
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 0;
  width: 100%;
  text-align: left;
  ">
  <img src="https://img.icons8.com/?size=60&id=62912&format=png" style="width: 20px; height: 20px;" />
  <span>Main Thoroughfares</span>
  </button>
  
  <button id="traffic-vehicles-toggle" title="Shopping Malls" style="
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 0;
  width: 100%;
  text-align: left;
  ">
  <img src="https://img.icons8.com/?size=50&id=10734&format=png" style="width: 20px; height: 20px;" />
  <span>Traffic Live</span>
  </button>
  <button id="traffic-segment-speed" title="Shopping Malls" style="
  display: flex;
  align-items: center;
  gap: 8px;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 0;
  width: 100%;
  text-align: left;
  ">
  <img src="https://img.icons8.com/?size=48&id=vwGXRtPWrZSn&format=png" style="width: 20px; height: 20px;" />
  <span>Historic Traffic</span>
  </button>
  
  </div>  
  <!---------------------------------------------------------- Reports  ------------------------------------------------------------------------>
  <div id="reports-options-panel">
    <button
      id="heatmap-toggle"
      title="Heatmap ON"
      style="
        display: flex;
        align-items: center;
        gap: 8px;
        background: none;
        border: none;
        cursor: pointer;
        padding: 4px 0;
        width: 100%;
        text-align: left;
      "
    >
      <img
        src="images/icons/heatmap.png"
        style="width:20px; height:20px;"
        alt="Heatmap ON"
      />
      <span>Heatmap ON</span>
    </button>
    <!-- ► Aquí va el slider de radio ► -->
  <label
  for="heatmap-radius"
  style="display:inline-block; margin: 0 0 0 12px; font-size:12px; color:#333;"
>
  Radio: <span id="heatmap-radius-value">100</span> m
</label>
<input
  type="range"
  id="heatmap-radius"
  min="100"
  max="5000"
  step="100"
  value="100"
  style="vertical-align:middle; margin-left:4px;"
/>
    <!-- Más botones u opciones aquí -->
  </div>
  
  <!---------------------------------------------------------- Settings    ------------------------------------------------------------------------>
  <div id="settings-panel">
    <button id="sound-toggle" style="
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
    ">
    <img src="https://img.icons8.com/?size=48&id=iWO20ZvCeU53&format=png" title="Sound Effects" style="width: 20px; height: 20px;" />
    </button>
    <button id="dark-mode" style="
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
    ">
    <img id="dark-mode-icon" src="https://img.icons8.com/?size=60&id=59841&format=png" title="Dark Mode" style="width: 20px; height: 20px;" />
    </button>
    <button id="dev-mode"  style="
    display: flex;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 0;
    width: 100%;
    text-align: left;
    ">
    <img src="https://img.icons8.com/?size=48&id=vJB83aasOd9i&format=png" title="Developer Tools" style="width: 20px; height: 20px;" />
    </button>
    
    </div>  
<!---------------------------------------------------------- Dev Mode  ------------------------------------------------------------------------>
<div id="dev-toolbar" class="toolbar-visible">


  <button id="pins-research" title="Add to Database">
    <img  id="retail-icon" 
    src="images/icons/database-add.png" 
    style="width:25px; height:25px; display: flex;"
    />
  </button>


  <button id="toggle-radius-limit" title="Increase Circle Radius">
    <img  id="retail-icon" 
    src="images/icons/circle-increase.png" 
    style="width:25px; height:25px; display: flex;"
    />
  </button>


    <button id="export-research" title="Download Custom Markers & Polygons to XLS">
    <img  id="export-excel" 
    src="images/icons/xls.png" 
    style="width:25px; height:25px; display: flex;"
    />
  </button>


  <button onclick="sendResearchPins()">Enviar a Google Sheets</button>


</div>     




      <div id="bottom-image-container">
<a href="https://www.marketspots.mx" target="_blank" rel="noopener">
  <img src="https://static.wixstatic.com/media/805cf6_1f6e397fdb7449bcbfda8dc022a66870~mv2.png" alt="Ir a mi sitio web" />
</a>
</div>
<div id="notes-panel">
  <div id="notes-header">
    <h2>Notes</h2>
    <button id="clear-notes" title="Erase Notes?">🗑️</button>
  </div>
  <textarea id="note-input" placeholder="Write something here..."></textarea>
  <button id="save-note" class="orange-btn">Save</button>
  <div id="notes-list"></div>
</div>  
<div id="traffic-panel" style="display: none;
">
<div style="display: flex; justify-content: space-between; align-items: center; font-weight: bold; margin-bottom: 10px;">
  Traffic Generators
  <button onclick="closeTrafficPanel()">✕</button>
</div>
<div id="avenue-control-content"></div>
<div style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 8px;">
  <button class="gray-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="clearAllAvenues">Clear</button>
  <button class="orange-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="selectAllAvenues">Select All</button>
</div>
</div>
<div id="city-panel" style="display: none;">
<div style="display: flex; justify-content: space-between; align-items: center; font-weight: bold; margin-bottom: 10px;">
  City Boundaries
  <button onclick="closeCityPanel()">✕</button>
</div>
<div id="location-control-content"></div>
<div style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 8px;">
  <button class="gray-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="clearAllLocations">Clear</button>
  <button class="orange-btn" style="font-size: 12px; padding: 6px 14px; min-width: 90px;" id="selectAllLocations">Select All</button>
</div>
</div>
<!-- Campo de búsqueda con autocompletado -->
<div id="autocomplete-container">
<div style="position: relative;">
<input id="search-input" type="text" style="font-size: 12px;" placeholder="Search Franchise or Location">
<div id="autocomplete-results" style="
position: absolute;
top: 100%;
left: 0;
width: 420px;     	     	/* ✅ fuerza el mismo ancho que el input */
max-height: 275px;
overflow-y: auto;
margin-top: 4px;
border: 1px solid #ccc;
border-radius: 5px;
background: #ffffff;
display: none;
font-size: 12px;
z-index: 10000;
"></div>
</div>
</div>
<!-- Popup de franquicias -->
<div id="popup" class="popup">
  <span class="popup-close" onclick="closePopup()">X</span>
  <div class="popup-header" id="popup-header"></div>
  <div class="popup-content" id="popup-content"></div>
  <button onclick="downloadExcel()">Download Report (Excel)</button>
</div>
<!-- Popup 2: Análisis de Radio -->
<div id="popup2" class="popup">
  <div class="popup-header">
    <span id="popup2-header" style="margin: 0 auto; text-align: center; width: 100%;"></span>
    <span class="popup-close" onclick="closePopup2()">X</span>
  </div>
  <!-- 1. Franquicias Top 5 -->
  <div id="franchise-section">
    <div class="popup-inline-data" style="text-align:center; font-weight: bold; margin-top: 10px; font-size: 12px;">
      Franchises Top 5
    </div>
    <div id="franchisechart"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <!-- 2. Subcategorías Top 5 -->
  <div id="subcategory-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Subcategories Top 5
    </div>
    <div id="subcategorychart"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <!-- 3. Retail Classification (Pie Operaciones) -->
  <div id="operation-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Retail Classification
    </div>
    <div id="operationPieChart"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <!-- 4. Lista de Shopping Centers en el radio -->
  <div id="operation-list-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px; color: #ff6600;">
      Shopping Centers on Radius:
    </div>
    <div id="operation-list" style="padding: 10px 20px; font-size: 12px; line-height: 1.6;"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <!-- 5. Scatter de Propiedades -->
  <div id="scatter-section">
    <div class="popup-inline-data" style="display: flex; flex-direction: column; align-items: center; margin-top: 20px; font-size: 12px;">
      <div style="font-weight: bold; margin-bottom: 8px;">
        Marketplace Properties
      </div>
      <select id="category-select" style="padding:4px 8px; font-size:12px;">
        <option value="localesRenta">Retail Spaces / Rent</option>
        <option value="localesVenta">Retail Spaces / Sale</option>
        <option value="terrenosRenta">Land Lot / Rent</option>
        <option value="terrenosVenta">Land Lot / Sale</option>
      </select>
    </div>
    <div id="scatterchart" style="width:100%; height:135%; margin-top: 10px;"></div>
    <div id="scatter-summary" style="padding:8px 0; font-size:14px; text-align:center;"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <!-- 6. NSE (Pie Socioeconómico) -->
  <div id="nse-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Influence Area by Socioeconomic Status
    </div>
    <div id="piechart"></div>
    <div class="popup-inline-data" id="popup2-extra" style="text-align:center; margin-top: 20px; font-size: 12px;"></div>
    <div class="separator" style="height: 2px; background-color: #d3d3d3; margin: 15px 0;"></div>
  </div>
  <!-- 7. Lista completa de franquicias en el radio -->
  <div id="list-section">
    <div class="popup-inline-data" style="text-align: center; font-weight: bold; margin-top: 20px; font-size: 12px;">
      Franchises Full List in Current Radius:
    </div>
    <div id="franchise-list" style="padding: 20px; font-size: 12px;"></div>
    <div style="text-align: center; margin: 20px 0;">
      <button onclick="downloadExcel()">Download Report (Excel)</button>
    </div>
  </div>
</div>

<!-- Botón menú hamburguesa -->

</div>

<!-- Panel lateral con filtros -->

<div id="filter-panel">

<div id="filter-header">

<span>Report Selection Menu</span>

<button onclick="toggleMenu()"></button></div>

<div id="filter-content">

<div class="filter-section location-filter">
  <div class="filter-header-row">
              	<h3>Locations:</h3>
              	<div class="filter-buttons-inline">
             	<button id="clearAllLocationsFilter" class="gray-btn">Clear</button>
             	<button id="selectAllLocationsFilter" class="orange-btn">Select All</button>
              	</div>
  </div>
  <div id="location-filter-content"></div>

</div>





<div class="filter-section franchises">     	
  <div class="filter-header-row">
<h3>Companies List:</h3>
<div class="filter-buttons-inline">
<button onclick="deselectAllMarkers()" class="gray-btn">Clear</button>
<button onclick="selectAllMarkers()" class="orange-btn">Select All</button>
</div>
</div>

<div id="pin-control-content"></div>
</div>
<div class="filter-section retail-classification">
<div class="filter-header-row">
<h3>Retail Classification:</h3>
<div class="filter-buttons-inline">
<button id="selectAllOperations" class="orange-btn">Select All</button>
</div>
</div>
<div id="operations-control-content"></div>
</div>
<div class="filter-section socioeconomic-status">
<div class="filter-header-row">
<h3>Socioeconomic:</h3>
<div class="filter-buttons-inline">
<button id="clearAllNSE" class="gray-btn">Clear</button>
<button id="selectAllNSE" class="orange-btn">Select All</button>
</div>
</div>
<div id="nse-control-content"></div>
</div>








</div>
</div>
</div>
<div id="ruler-popup" style="
  display: none;
  position: fixed;
top: 12px;
right: 250px;
transform: translateX(-50%);
  background: #000000;
  border: 0px solid #ffffff;
  border-radius: 6px;
  padding: 10px 40px;
  z-index: 5;
  font-family: 'Segoe UI', sans-serif;
  font-size: 13px;
  color: #ffffff;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
">
 <span id="ruler-popup-text">Distance: </span>
 <span style="margin-left: 15px; cursor: pointer; font-weight: bolder; font-size: 14px; color: #ffffff;" onclick="closeRulerPopup()">✕</span>
 
</div>
<div id="toast"></div>
 
 
<div id="research-pin-form">
	<label>Franchise:</label><br>
	<input id="research-franchise" type="text"><br>
  <label>Operations:</label><br>
  <input id="research-operations" type="text" style="top:50px" list="operations-options"><br>
  <datalist id="operations-options">
    <option value="Airports"></option>
    <option value="Community Centers">
    <option value="Free Standings">
    <option value="Neighborhood Centers">
    <option value="Power Centers">
    <option value="Shopping Malls">
  </datalist>
	<label>Address:</label><br>
	<input id="research-address" type="text"><br>
  <label>Location:</label><br>
  <input id="research-location" type="text" style="top:50px" list="municipality-options"><br>
  <datalist id="municipality-options">
    <option value="Altamira">
    <option value="Apodaca">
    <option value="Ciénega de Flores">
    <option value="Ciudad Madero">
    <option value="El Carmen">
    <option value="Escobedo">
    <option value="García">
    <option value="Guadalupe">
    <option value="Juárez">
    <option value="Laredo TX">
    <option value="Monterrey">
    <option value="Pesquería">
    <option value="Salinas Victoria">
    <option value="San Nicolás de los Garza">
    <option value="San Pedro Garza García">
    <option value="Santa Catarina">
    <option value="Santiago">
    <option value="Tampico">
    <option value="Zuazua">
  </datalist>
  <div style="margin-top: 30px;">
    <button class="orange-btn"; onclick="saveResearchPin()">Guardar</button>
    <button class="gray-btn"; onclick="closeResearchPinForm()">Cancelar</button>
  </div>
</div>
<div id="polygon-tooltip" style="
  position: absolute;
  display: none;
  background: black;
  color: white;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 13px;
  pointer-events: none;
  z-index: 9999;
  white-space: nowrap;
"></div>
<div id="start-screen">
  <img src="https://i.gifer.com/embedded/download/Gpoq.gif"/>
</div>
<div id="municipios-panel">
  <h3>
    City Limits
    <button id="municipios-close" title="Cerrar">&times;</button>
  </h3>
  <!-- Botones de Select All / Clear All -->
  <div class="btn-group" style="text-align: center; margin-bottom: 8px;">
    <button id="selectAllMunicipios" class="gray-btn">Select All </button>
    <button id="clearAllMunicipios" class="orange-btn"> Clear All </button>

  </div>
  <div id="municipios-list"></div>


</div>

<div id="loading-screen" style="display:none;">
  <div class="loading-content">
    <div class="spinner"></div>
    <!-- NUEVO: muestra el tiempo transcurrido -->
    <div id="loading-timer" style="font-size:24px; margin:8px 0;">00:00</div>
    <p>Processing...</p>
  </div>
</div>


<script>
function showToast(message) {
let toast = document.getElementById("toast");
const fullscreenEl = document.fullscreenElement;
if (!toast) {
toast = document.createElement("div");
toast.id = "toast";
toast.style.position = "fixed";
toast.style.top = "10%"; // parte superior centrada
toast.style.left = "50%";
toast.style.transform = "translateX(-50%)";
toast.style.backgroundColor = "#ff6600";
toast.style.color = "white";
toast.style.padding = "10px 20px";
toast.style.borderRadius = "6px";
toast.style.fontSize = "14px";
toast.style.zIndex = "100";
toast.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
toast.style.transition = "opacity 0.5s ease"; // transición suave
toast.style.opacity = "0"; // inicia invisible
 (fullscreenEl || document.body).appendChild(toast);
} else {
  if (fullscreenEl && toast.parentNode !== fullscreenEl) {
              	fullscreenEl.appendChild(toast);
  } else if (!fullscreenEl && toast.parentNode !== document.body) {
              	document.body.appendChild(toast);
  }
}
toast.textContent = message;
toast.style.display = "block";
toast.style.opacity = "1";
clearTimeout(toast.hideTimeout);
toast.hideTimeout = setTimeout(() => {
toast.style.opacity = "0"; // inicia desvanecimiento
// Después de la transición (500ms), ocúltalo completamente
setTimeout(() => {
              	toast.style.display = "none";
  }, 500);
}, 5000);
}

/**
 Guarda como “base” la franquicia clicada
 */
function setBaseFranchise(marker) {
  // 1) Pedir parámetros
  const km          = parseFloat(prompt('Base radius (km):', (maxCircleRadius / 1000))) || (maxCircleRadius / 1000);
  const radius      = km * 1000;
  const numResults  = parseInt(prompt('How many candidates to show?','3'),10) || 3;
  const threshold   = parseInt(prompt('Minimum threshold (0–100):','85'),10) || 85;

  // 2) Calcular métricas base (SIN usar baseMetricsOverride)
  const baseMetrics = getMetrics(marker.getPosition(), radius);

  // 3) Guardar todo en la variable global
  baseFranchiseParams = {
    franchiseName: marker.franchise,
    center:        marker.getPosition(),   // <-- guardo el centro original
    radius,
    numResults,
    threshold,
    baseMetrics
  };

  showToast(`🚩 Base established: ${marker.franchise}`);
}


const nseColors = {"A/B+": "#41934B", "C+": "#FF6600", "C": "#EFB451","C-": "#967164", "D+": "#2F267C", "D": "#56A8DE", "E": "#FF0000",};
let map= []; markers = [], polygons = [], currentCircle = null, currentCircleData = [];
let activeAvenues = new Set();
let activeLocations = new Set();
let activeLocationsFilter = new Set();
let activeNSEs = new Set();
let activeOperations = new Set();
let chartsColor = "transparent";
let chartsTextColor = "#ff6600"
let currentKmzLayer = null;
let currentPolygon = null;
let customPolygons = [];
let drawnCircle = null;
let drawingManager;
let drawnPolygons = [];
let fillOpacityLevel = 0.1;
let heatmap;
let importedKMZ = [];
let infoWindow;
let isDarkMode = false;
let isRestoringCityBoundaries = false;
let isSoundEnabled = localStorage.getItem('soundEnabled') === 'true';
let localMarkers = [];
let localPins = [];
let locationPolygons = {};
let mapClickListener = null;
let maxCircleRadius = 3500;
let nsePolygons = {};
let pinMode = null;
let poiMarkers = [];
let polylines = [];
let popup2Data = null;
let researchPinMode = false;
let addPortfolioMarker = false;
let rulerColor = "#000000"
let rulerListener = null;
let rulerPoints = [];
let rulerPolyline = null;
let selectedResearchCoords = null;
let tempDistanceLabel = null;
let tempRulerLine = null;
let tooltipTimeout;
let tooltipDiv;
let tooltipOverlay;
let trafficLayer;
let userLocationMarker = null;
let wasFilterPanelOpen = false;
let wasCityPanelVisible = false;
let wasPopupVisible = false;
let wasPopup2Visible = false;
let wasRulerPopupVisible = false;
let wasTrafficPanelVisible = false;
let inmobiliariaLoaded = false;      
let inmuebleMarkers = [];            
let inmuebleVisible = false;    

let wktCache = {};

// ── Variables globales para limpiar análisis previo
let analysisCircles = [];
let analysisMarkers = [];
let currentAnalyzedFranchise = null;

// —————————————————————————————
// 1) Almacenamiento de la franquicia base
// —————————————————————————————
let baseFranchiseParams = null;
let currentExpansionMarker = null;

// Modo para colocar el nuevo “pin de expansión”
let expansionPinMode = false;

// Para la cuenta regresiva en análisis de franquicia
let avgMsPerPoint = null;


window.importedKMZMarkers  = window.importedKMZMarkers  || [];
window.importedKMZPolygons = window.importedKMZPolygons || [];

let circleColor = isDarkMode ? "#ff6600" : "#000000";  //////////////////////////////////////////////////     No mover 

let propRadius = 50;


let retailSpaceRent = "#FFE700"
let retailSpaceSale = "#00FF00"
let landLotSale = "#FF0000"
let landLotRent = "#0000FF"


  // 1) Empieza la StarScreen (ya es visible por defecto en el CSS)
  const startScreen = document.getElementById('start-screen');
  // 2) Programa su ocultamiento a los 10 s
  setTimeout(() => {
    // Fade-out
    startScreen.style.opacity = '0';
    // Al terminar la transición, la quitamos del flujo
    startScreen.addEventListener('transitionend', () => {
      startScreen.style.display = 'none';
    });
  }, 6500);


// ① Lista de ciudades (nombres como aparecen en tus JSON)

const cities = ['altamira','ciudad-madero','durango-durango','gomez-palacio','lerdo','tampico','apodaca','escobedo','general-escobedo','garcia','guadalupe','guadalupe-nuevo-leon','juarez-nuevo-leon','saltillo',
'monterrey','san_nicolas','san_nicolas_de_los_garza','san-nicolas-de-los-garza','san_pedro','san-pedro-garza-garcia','san-pedro-garza-garcía','matamoros-tamaulipas','monclova','nuevo-laredo','piedras-negras','reynosa','torreon',
'santa_catarina','santa_catarina_nuevo_leon','santa-catarina-nuevo-leon','victoria-tamaulipas'];

// ─── Reemplaza tu sección de propertyConfig en turn8file1 por esto ───

const baseFolder = 'files/props_data';
const propertyConfig = {
  localesRenta: {
    prefixFolder: `${baseFolder}/noreste`,
    filePrefix:   'locales-renta',
    isMarker:     false,
    circleOptions:{ color: retailSpaceRent, radius: propRadius }
  },
  localesVenta: {
    prefixFolder: `${baseFolder}/noreste`,
    filePrefix:   'locales-venta',
    isMarker:     false,
    circleOptions:{ color: retailSpaceSale, radius: propRadius }
  },
  terrenosRenta: {
    prefixFolder: `${baseFolder}/noreste`,
    filePrefix:   'terrenos-comerciales-renta',
    isMarker:     false,
    circleOptions:{ color: landLotRent , radius: propRadius }
  },
  terrenosVenta: {
    prefixFolder: `${baseFolder}/noreste`,
    filePrefix:   'terrenos-comerciales-venta',
    isMarker:     false,
    circleOptions:{ color: landLotSale, radius: propRadius }
  }
};
const propertyMarkers = { localesRenta:[], localesVenta:[], terrenosRenta:[], terrenosVenta: [] };
const propertyVisible = { localesRenta:false, localesVenta:false, terrenosRenta:false, terrenosVenta:false};
  async function loadCategory(category) {
  const cfg      = propertyConfig[category];
  const overlays = propertyMarkers[category];
  if (overlays.length) return;
  for (const city of cities) {
    for (let page = 1; ; page++) {
      const url = `${cfg.prefixFolder}/${city}_${cfg.filePrefix}_p${page}.json`;


      try {
        const res  = await fetch(url);
        if (!res.ok) break;  // 404 → no hay más páginas
        const data = await res.json();
        data.forEach(item => {
          const lat = parseFloat(item.Lat),
                lng = parseFloat(item.Lng);
          if (isNaN(lat) || isNaN(lng)) return;
          // Crea marker o círculo según cfg.isMarker
          let overlay;
          if (cfg.isMarker) {
            overlay = new google.maps.Marker({
              position: { lat, lng },
              map,
              visible: false,
              title: item.Título,
              icon: {
                url: cfg.iconUrl,
                scaledSize: new google.maps.Size(30, 32),
              zIndex: 3

              }
            });
          } else {
            overlay = new google.maps.Circle({
              center:   { lat, lng },
              radius:   cfg.circleOptions.radius,
              strokeColor: "#FFFFFF",
              strokeWeight: 0,
              fillColor: cfg.circleOptions.color,
              fillOpacity: .85,
              map,
              visible: false,
              zIndex: 3
            });
          }
          // Guarda datos extra en _props
          overlay._props = {
            título:     item.Ubicación,
            superficie: item.Superficie,
            precio:     item.Precio,
            enlace:     item.Enlace   
          };
          overlay.addListener('click', () => {
  const url = overlay._props.enlace;
  if (url) {
    // Si no tiene protocolo, puedes forzarlo:
    const fullUrl = url.startsWith('http') ? url : `https://${url}`;
    window.open(fullUrl, '_blank');
  }
});
overlay.addListener('mouseover', e => {
  const { título, superficie, precio } = overlay._props;
  // 1) Convertir a números puros
  const supNum = Number(
    superficie.toString().replace(/[^\d.-]/g, '')
  );
  const preNum = Number(
    precio.toString().replace(/[^\d.-]/g, '')
  );
  // 2) Formatear para mostrar
  const supStr = isNaN(supNum)
    ? 'N/A'
    : supNum.toLocaleString(undefined, { maximumFractionDigits: 0 }) + ' m²';
  const preStr = isNaN(preNum)
    ? 'N/A'
    : '$' + preNum.toLocaleString(undefined, { maximumFractionDigits: 0 });
  // 3) Calcular MX/m² y formatear
  let valorM2Str = 'N/A';
  if (!isNaN(supNum) && supNum > 0 && !isNaN(preNum)) {
    const valorM2 = preNum / supNum;
    valorM2Str = '$' + valorM2
      .toLocaleString(undefined, { maximumFractionDigits: 0 });
  }
  // 4) Inyectar todo en el tooltip
  tooltipDiv.innerHTML = `
    <div style="
      background: black;
      color: white;
      padding: 6px 8px;
      border-radius: 1px;
      font-size: 12px;
    ">
      <strong>${título}</strong><br>
      Area: ${supStr}, Ticket: ${preStr}, MX/m²: ${valorM2Str}
    </div>
  `;
  tooltipDiv.style.display = 'block';
});
          overlay.addListener('mousemove', e => {
            const proj = tooltipOverlay.getProjection();
            const pos  = proj.fromLatLngToDivPixel(e.latLng);
            tooltipDiv.style.left = pos.x + 'px';
            tooltipDiv.style.top  = pos.y + 'px';
          });
          overlay.addListener('mouseout', () => {
            tooltipDiv.style.display = 'none';
          });
          overlays.push(overlay);
        });
      } catch (e) {
        console.warn(`No se encontró ${url}, deteniendo ${category}/${city}`, e);
        break;
      }
    }
  }
  console.log(`✅ Cargada categoría ${category}: ${overlays.length} objetos.`);
}
  function toggleCategory(category, visible) {
    propertyVisible[category] = visible;
    propertyMarkers[category].forEach(o => o.setVisible(visible));
  }
  function toggleAllProperties() {
    const anyVisible = Object.values(propertyVisible).some(v => v);
    const newState   = !anyVisible;
    Object.keys(propertyVisible).forEach(cat => {
      propertyVisible[cat] = newState;
      propertyMarkers[cat].forEach(o => o.setVisible(newState));
      document
        .querySelector(`#toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`)
        .checked = newState;
    });
  }
</script>
<script>
const darkMapStyle = [
{ elementType: 'geometry', stylers: [{ color: '#1d1d1d' }] },
  { elementType: 'labels.icon', stylers: [{ visibility: 'off' }] },
  { elementType: 'labels.text.fill', stylers: [{ color: '#616161' }] },
  { elementType: 'labels.text.stroke', stylers: [{ color: '#0000' }] },
  { featureType: 'administrative', elementType: 'geometry', stylers: [{ color: '#FF6600' }] },
  { featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#000000' }] },
  { featureType: 'poi', elementType: 'labels.text.fill', stylers: [{ color: '#FF6600' }] },
  { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#383838' }] },
  { featureType: 'road.arterial', elementType: 'labels.text.fill', stylers: [{ color: '#383838' }] },
  { featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#383838' }] },
  { featureType: 'transit', elementType: 'geometry', stylers: [{ color: '#0000' }] },
  { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#000000' }] },
  { featureType: 'water', elementType: 'labels.text.fill', stylers: [{ color: '#000000' }] }
];
const lightMapStyle = [
 { elementType: 'geometry', stylers: [{ color: '#f5f5f5' }] },
 { elementType: 'labels.icon', stylers: [{ visibility: 'off' }] },
 { elementType: 'labels.text.fill', stylers: [{ color: '#616161' }] },
 { elementType: 'labels.text.stroke', stylers: [{ color: '#f5f5f5' }] },
 { featureType: 'administrative', elementType: 'geometry', stylers: [{ color: '#c9c9c9' }] },
 { featureType: 'administrative.neighborhood', stylers: [{ visibility: 'off' }] },
 { featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#eeeeee' }] },
 { featureType: 'poi', elementType: 'labels.text.fill', stylers: [{ color: '#757575' }] },
 { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#dadada' }] },
 { featureType: 'road.arterial', elementType: 'labels.text.fill', stylers: [{ color: '#333333' }] },
 { featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#dadada' }] },
 { featureType: 'transit', elementType: 'geometry', stylers: [{ color: '#e5e5e5' }] },
 { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#E1f6ff' }] },
 { featureType: 'water', elementType: 'labels.text.fill', stylers: [{ color: '#9e9e9e' }] }
];

function initMap() {
    map = new google.maps.Map(document.getElementById("map"), {
    center: { lat: 25.6860, lng: -100.3169 }, // Monterrey lat: 25.6860, lng: -100.3169 /// Tamaulipas lat: 23.74309, lng: -99.14366 
    zoom: 7,
    styles: lightMapStyle,
    mapTypeControl: true,
    mapTypeControlOptions: {
      style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
      position: google.maps.ControlPosition.TOP_RIGHT,
      mapTypeIds: ["roadmap", "satellite"]
    },
    fullscreenControl: true,
    fullscreenControlOptions: { position: google.maps.ControlPosition.TOP_RIGHT },
    streetViewControl: true,
    streetViewControlOptions: { position: google.maps.ControlPosition.TOP_RIGHT }
  
  });


// ----------------- NUEVO CÓDIGO -----------------
// Intentar restaurar posición previa
const savedCenter = JSON.parse(localStorage.getItem("mapCenter"));
const savedZoom   = Number(localStorage.getItem("mapZoom"));
if (savedCenter && !isNaN(savedZoom)) {
 map.setCenter(savedCenter);
 map.setZoom(savedZoom);
}
// -------------------------------------------------
// Cada vez que el mapa quede inactivo (idle), guardamos centro y zoom
map.addListener("idle", () => {
 const c = map.getCenter();
 localStorage.setItem("mapCenter", JSON.stringify({ lat: c.lat(), lng: c.lng() }));
 localStorage.setItem("mapZoom", map.getZoom());
});  




localStorage.removeItem("customPolygons");
localStorage.removeItem("customPins");
localStorage.removeItem("importedKMZ");
localStorage.removeItem("excelData");
localStorage.removeItem("devPasswordValidated");


  tooltipDiv     = document.getElementById("tooltip");
  tooltipOverlay = new google.maps.OverlayView();
  tooltipOverlay.onAdd = function() {
    this.getPanes().overlayMouseTarget.appendChild(tooltipDiv);
  };
  tooltipOverlay.draw = function() { /* no hace falta */ };
  tooltipOverlay.onRemove = function() {
    tooltipDiv.parentNode && tooltipDiv.parentNode.removeChild(tooltipDiv);
  };
  tooltipOverlay.setMap(map);
updateSoundButton();


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

let hideTooltipTimeout;
let suspendMasterSync = false;
const visibleMunicipios = new Set();

// 0) Estructuras para guardar polígonos y labels
const municipioPolygons = {};
const municipioLabels   = {};

// 0b) Define los estados que quieres mostrar
const visibleStates = new Set(['Coahuila', 'Durango', 'Nuevo León', 'Jalisco']);

// 1) Carga el GeoJSON y crea polígonos nativos (sin añadirlos al mapa)
fetch('files/kmz/MX59.json')
  .then(res => res.json())
  .then(fc => {
    const lista = document.getElementById('municipios-list');
    lista.innerHTML = '';  // limpia lista previa

    // 1.1) Inicializa la estructura anidada { estado: { municipio: [polygons], label: Marker } }
    visibleStates.forEach(state => {
      municipioPolygons[state] = {};
      municipioLabels[state]   = {};
    });

    // 1.2) Recorre features para crear las llaves de municipio
    fc.features.forEach(f => {
      const state = f.properties.NAME_1;
      if (!visibleStates.has(state)) return;
      const muni = f.properties.NAME_2.trim();
      if (!muni) return;
      municipioPolygons[state][muni] = [];
      municipioLabels[state][muni]   = null;
    });

    // 1.3) Crea polígonos y labels
    fc.features.forEach(f => {
      const state = f.properties.NAME_1;
      if (!visibleStates.has(state)) return;
      const muni = f.properties.NAME_2.trim();
      if (!muni) return;

      // Coordenadas al formato {lat,lng}
      const rawCoords = f.geometry.type === 'Polygon'
        ? [f.geometry.coordinates]
        : f.geometry.coordinates;
      const paths = rawCoords.map(poly =>
        poly[0].map(c => ({ lat: c[1], lng: c[0] }))
      );

      // — a) Crear y guardar el polígono —
      const polygon = new google.maps.Polygon({
        paths,
        fillColor:   '#000000',
        fillOpacity: fillOpacityLevel,
        strokeColor: '#ff6600',
        strokeOpacity: 1,
        strokeWeight: 2,
        clickable:   false,
        zIndex:      1
      });
      municipioPolygons[state][muni].push(polygon);

      // — b) Crear y guardar el label en el centro del polígono —
      const bounds = new google.maps.LatLngBounds();
      paths.forEach(ring => ring.forEach(pt => bounds.extend(pt)));
      const center = bounds.getCenter();
      const labelMarker = new google.maps.Marker({
        position: center,
        map:      null,  // arranca oculto
        icon: {
          path:  google.maps.SymbolPath.CIRCLE,
          scale: 0      // icono invisible
        },
        label: {
          text:       muni,
          color:      '#ff6600',
          fontSize:   '1px',
          fontWeight: 'bold'
        },
        clickable: false,
        zIndex:    2
      });
      municipioLabels[state][muni] = labelMarker;
    });

    // 2) Agrupa los municipios por estado para la UI
    const stateToMunicipios = {};
    Object.keys(municipioPolygons).forEach(state => {
      stateToMunicipios[state] = Object.keys(municipioPolygons[state]);
    });

    // 3) Construye los checkboxes estado → municipios (con expand/collapse)
    Object.keys(stateToMunicipios).sort().forEach(state => {
      const group = document.createElement('div');
      group.className = 'state-group';

      // 3.1) Header con toggle icon y checkbox maestro
      const header = document.createElement('div');
      header.className = 'state-header';
      header.style.display = 'flex';
      header.style.alignItems = 'center';

      const toggleIcon = document.createElement('span');
      toggleIcon.textContent = '▶';
      toggleIcon.style.cursor = 'pointer';
      toggleIcon.style.marginRight = '6px';

      const stateCb = document.createElement('input');
      stateCb.type    = 'checkbox';
      stateCb.checked = false;

      const stateLabel = document.createElement('span');
      stateLabel.textContent = state;
      stateLabel.style.marginLeft = '4px';

      header.append(toggleIcon, stateCb, stateLabel);
      group.appendChild(header);

      // 3.2) Contenedor de hijos (municipios), ocultable
      const muniList = document.createElement('div');
      muniList.style.paddingLeft = '20px';
      muniList.style.marginTop   = '4px';
      muniList.style.display     = 'none';

      const muniCbs = [];
      stateToMunicipios[state].sort().forEach(muni => {
        const label = document.createElement('label');
        label.style.display     = 'block';
        label.style.cursor      = 'pointer';
        label.style.userSelect  = 'none';

        const cb = document.createElement('input');
        cb.type          = 'checkbox';
        cb.dataset.state = state;
        cb.dataset.muni  = muni;
        cb.checked       = false;

        // Listener de hijo: dibuja/oculta polígono y label
        cb.addEventListener('change', () => {
          municipioPolygons[state][muni].forEach(poly =>
            poly.setMap(cb.checked ? map : null)
          );
          municipioLabels[state][muni].setMap(cb.checked ? map : null);

          if (!suspendMasterSync) {
            stateCb.checked = muniCbs.every(chk => chk.checked);
          }
        });

        label.append(cb, document.createTextNode(' ' + muni));
        muniList.appendChild(label);
        muniCbs.push(cb);
      });

      // 3.3) Listener del maestro: marca/desmarca todos los hijos
      stateCb.addEventListener('change', () => {
        suspendMasterSync = true;
        muniCbs.forEach(cb => {
          cb.checked = stateCb.checked;
          cb.dispatchEvent(new Event('change'));
        });
        suspendMasterSync = false;
      });

      // 3.4) Toggle expand/collapse
      toggleIcon.addEventListener('click', () => {
        const collapsed = muniList.style.display === 'none';
        muniList.style.display = collapsed ? 'block' : 'none';
        toggleIcon.textContent = collapsed ? '▼' : '▶';
      });

      group.appendChild(muniList);
      lista.appendChild(group);
    });
  });

// 4) Botones de “Seleccionar todo” / “Limpiar todo”
const selectAllBtn = document.getElementById('selectAllMunicipios');
const clearAllBtn  = document.getElementById('clearAllMunicipios');

selectAllBtn.addEventListener('click', () => {
  document.querySelectorAll('#municipios-list input[type="checkbox"]')
    .forEach(cb => {
      if (!cb.checked) {
        cb.checked = true;
        cb.dispatchEvent(new Event('change'));
      }
    });
});

clearAllBtn.addEventListener('click', () => {
  document.querySelectorAll('#municipios-list input[type="checkbox"]')
    .forEach(cb => {
      if (cb.checked) {
        cb.checked = false;
        cb.dispatchEvent(new Event('change'));
      }
    });
});

// 5) Toggle del panel de municipios
const toggleBtn = document.getElementById('city-toggle');
const panel     = document.getElementById('municipios-panel');

toggleBtn.addEventListener('click', () => {
  const isOpen = panel.style.display === 'block';
  if (isOpen) {
    panel.style.display = 'none';
    if (currentCircle && currentCircleData.length > 0) {
      document.getElementById('popup2').style.display = 'block';
    }
  } else {
    panel.style.display = 'block';
    document.getElementById('popup2').style.display = 'none';
  }
});

// Cerrar panel con la “X”
document.getElementById('municipios-close').addEventListener('click', () => {
  panel.style.display = 'none';
  if (currentCircle && currentCircleData.length > 0) {
    document.getElementById('popup2').style.display = 'block';
  }
});

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    
  playSound("sounds/start.mp3");
// 1) Toggle Locales en Renta
document.getElementById('toggle-locales-renta')
  .addEventListener('change', async e => {
    if (e.target.checked) {
      await loadCategory('localesRenta');
    }
    toggleCategory('localesRenta', e.target.checked);
    // ← Aquí
    if (currentCircle) showPopup2FromCircle(currentCircle);
  });
// 2) Toggles de localesVenta, terrenosRenta y terrenosVenta
['localesVenta','terrenosRenta','terrenosVenta'].forEach(cat => {
  const id = `toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`;
  document.getElementById(id)
    .addEventListener('change', async e => {
      if (e.target.checked) {
        await loadCategory(cat);
      }
      toggleCategory(cat, e.target.checked);
      // ← Aquí
      if (currentCircle) showPopup2FromCircle(currentCircle);
    });
});
// 3) Toggle “Mostrar/Ocultar Todas”
document.getElementById('toggle-all-properties')
  .addEventListener('click', async () => {
    const anyVisible = Object.values(propertyVisible).some(v => v);
    const newState   = !anyVisible;
    for (const cat of Object.keys(propertyConfig)) {
      if (newState && propertyMarkers[cat].length === 0) {
        await loadCategory(cat);
      }
      toggleCategory(cat, newState);
      // sincroniza el checkbox
      document
        .getElementById(`toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`)
        .checked = newState;
    }
    // ← Aquí, una sola vez al final
    if (currentCircle) showPopup2FromCircle(currentCircle);
  });
//////////////////////////////////    Oculta Draw Tools Bar cuando se activan       ////////////////////////////////////////////////////////////////////////////
  document.getElementById("drawPolygonBtn").addEventListener("click", () => {
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
});
document.getElementById("local-pin-toggle").addEventListener("click", () => {
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
});

document.getElementById("exportKmzBtn").addEventListener("click", () => {
const panel = document.getElementById("export-files-panel");
if (panel) panel.style.display = "none";
});

function handleKMZFile(evt) {
  const file = evt.target.files[0];
  if (!file) return;
  file.arrayBuffer()
    .then(buf => JSZip.loadAsync(buf))
    .then(zip => {
      const kmlName = Object.keys(zip.files)
        .find(name => name.toLowerCase().endsWith('.kml'));
      return zip.file(kmlName).async('string');
    })
    .then(kmlText => {
      const kmlDoc = new DOMParser().parseFromString(kmlText, 'application/xml');
      const geojson = toGeoJSON.kml(kmlDoc);
      map.data.addGeoJson(geojson);
      map.data.setStyle({
        strokeColor: '#FF0000',
        strokeWeight: 2,
        fillColor: '#FF0000',
        fillOpacity: fillOpacityLevel,
      });
    })
    .catch(console.error);
}


// Opcional: cerrar el panel si se hace clic fuera de él


// Import Files Trigger:
document.getElementById("import-files").addEventListener("click", () => {
  const panel = document.getElementById("import-files-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
// Opcional: cerrar el panel si se hace clic fuera de él
document.addEventListener("click", (e) => {
  const panel = document.getElementById("import-files-panel");
  const button = document.getElementById("import-files");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
// Open Draw Tools:
document.getElementById("draw-tools").addEventListener("click", () => {
  const panel = document.getElementById("draw-tools-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
// Opcional: cerrar el panel si se hace clic fuera de él
document.addEventListener("click", (e) => {
  const panel = document.getElementById("draw-tools-panel");
  const button = document.getElementById("draw-tools");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
/////////////////////////////////////////////          City Options Panel        ///////////////////////////////////////////////////////////////////////////
// ─── INSERTAR A CONTINUACIÓN ────────────────────────────────────────────────
// Botón “Mostrar/Ocultar Todos”
document.getElementById('toggle-all-properties')
  .addEventListener('click', toggleAllProperties);
// Cada checkbox de categoría
['localesRenta','localesVenta','terrenosRenta','terrenosVenta']
  .forEach(cat => {
    document.getElementById(
      `toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`
    ).addEventListener('change', e =>
      toggleCategory(cat, e.target.checked)
    );
  });
  Object.keys(propertyConfig).forEach(cat => {
  const cb = document.getElementById(`toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`);
  if (cb) cb.checked = false;
});
// ─── AÑADIR justo aquí ────────────────────────────────────────────
// Asegura que al cargar la página NO haya nada marcado
Object.keys(propertyConfig).forEach(cat => {
  const id = `toggle-${cat.replace(/([A-Z])/g,'-$1').toLowerCase()}`;
  const cb = document.getElementById(id);
  if (cb) cb.checked = false;
});
/////////////////////////////////////////              Retail Options Panel          /////////////////////////////////////////////////////////////
document.getElementById("retail-options").addEventListener("click", () => {
  const panel = document.getElementById("retail-options-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
// Opcional: cerrar el panel si se hace clic fuera de él
document.addEventListener("click", (e) => {
  const panel = document.getElementById("retail-options-panel");
  const button = document.getElementById("retail-options");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
/////////////////////////////////////////              Traffic Options Panel          /////////////////////////////////////////////////////////////
document.getElementById("traffic-options").addEventListener("click", () => {
  const panel = document.getElementById("traffic-options-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
// Opcional: cerrar el panel si se hace clic fuera de él
document.addEventListener("click", (e) => {
  const panel = document.getElementById("traffic-options-panel");
  const button = document.getElementById("traffic-options");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
/////////////////////////////////////////             Reports        /////////////////////////////////////////////////////////////
document.getElementById("reports-options").addEventListener("click", () => {
  const panel = document.getElementById("reports-options-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
document.addEventListener("click", (e) => {
  const panel = document.getElementById("reports-options-panel");
  const button = document.getElementById("reports-options");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
/////////////////////////////////////////              Settings         /////////////////////////////////////////////////////////////
document.getElementById("settings").addEventListener("click", () => {
  const panel = document.getElementById("settings-panel");
  const isVisible = panel.style.display === "flex";
  panel.style.display = isVisible ? "none" : "flex";
});
// Opcional: cerrar el panel si se hace clic fuera de él
document.addEventListener("click", (e) => {
  const panel = document.getElementById("settings-panel");
  const button = document.getElementById("settings");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
const importIcon = document.getElementById("import-icon");
function updateImportIcon(isDark) {
  if (importIcon) {
    importIcon.src = isDark
      ? "https://static.wixstatic.com/media/805cf6_a527d5bf395f4bcaa236eeebc9e139b2~mv2.png" // Dark
      : "https://static.wixstatic.com/media/805cf6_fa3277ade0834a39bed9c560c1fcc126~mv2.png"; // Light
  }
}
document.getElementById("poi-toggle-btn").addEventListener("click", () => {
  const box = document.getElementById("poi-search-box");
  box.style.display = box.style.display === "none" ? "flex" : "none";
});
// 👇 Ocultar el panel de exportación al hacer clic fuera
document.addEventListener("click", (e) => {
  const panel = document.getElementById("poi-search-box");
  const button = document.getElementById("poi-toggle-btn");
  if (!panel.contains(e.target) && !button.contains(e.target)) {
    panel.style.display = "none";
  }
});
document.getElementById("toggle-radius-limit").addEventListener("click", () => {
  if (maxCircleRadius === 3500) {
    maxCircleRadius = 50000;
    showToast("🔓 Radius limit 50,000 m");
  } else {
    maxCircleRadius = 3500;
    showToast("🔒 Radius limit 3,500 m (original)");
  }
});
document.getElementById("poi-clear-button").addEventListener("click", () => {
  // Borrar texto del input
  document.getElementById("poi-search-input").value = "";
  // Eliminar pines del mapa
  poiMarkers.forEach(marker => marker.setMap(null));
  poiMarkers = [];
});
function savePolygonToLocalStorage(polygon) {
  // 1) Recupera el array existente (o uno vacío)
  const stored = JSON.parse(localStorage.getItem("customPolygons") || "[]");
  // 2) Extrae el path
  const paths = polygon.getPath().getArray().map(coord => ({
    lat: coord.lat(),
    lng: coord.lng()
  }));
  // 3) Construye el objeto que quieres persistir
  const polygonData = {
    name: polygon.name || "",                           // Asigna la propiedad .name cuando crees el polígono
    paths: paths,
    strokeColor: polygon.get("strokeColor"),
    fillColor: polygon.get("fillColor"),
    fillOpacity: polygon.get("fillOpacity"),
    clickable: polygon.get("clickable"),
    zIndex: polygon.get("zIndex")
  };
  // 4) Guarda
  stored.push(polygonData);
  localStorage.setItem("customPolygons", JSON.stringify(stored));
}
    // Botón de la toolbar
    document.getElementById("drawPolygonBtn").addEventListener("click", () => {
      drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
    });
    
    // 👇 Mueve este bloque AQUÍ dentro de initMap para asegurar que el botón ya existe en el DOM
    document.getElementById("poi-search-button").addEventListener("click", async () => {
    const query = document.getElementById("poi-search-input").value.trim();
    if (!query) {
      alert("Escribe algo para buscar!");
      return;
    }
    const results = await searchPlacesByText(query);
    renderPOIMarkers(results);
  });
  
  map.addListener("maptypeid_changed", () => {
    if (map.getMapTypeId() === "satellite") {
      map.setTilt(0);
      map.setHeading(0);
    }
  });
  initLayers(); // 👈 Se llama correctamente aquí
}
function initLayers() {
  // TRAFFIC VEHICLES
// Inicializa la capa de tráfico
trafficLayer = new google.maps.TrafficLayer();
// 1) Live Traffic (toggle on/off y desactiva sólo al encender)
document.getElementById("traffic-vehicles-toggle").addEventListener("click", () => {
  const isActive = !!trafficLayer.getMap();
  if (isActive) {
    trafficLayer.setMap(null);
  } else {
    deactivateAllTrafficLayers();
    trafficLayer.setMap(map);
  }
});
// 2) Historic Traffic (ahora en su propio listener)
document.getElementById("traffic-segment-speed").addEventListener("click", () => {
  const isActive = trafficIsVisible;          // tu flag que marcas en drawTrafficVolumeBySegment()
  if (isActive) {
    // Si ya estaba ON, apágalo
    deactivateAllTrafficLayers();
  } else {
    // Si estaba OFF, apaga todo y luego dibuja histórico
    deactivateAllTrafficLayers();
    drawTrafficVolumeBySegment();
  }
});

  // HEAT ZONES dinámicas
  heatmap = new google.maps.visualization.HeatmapLayer({
  data: [],
  map: null,
  radius: Number(document.getElementById("heatmap-radius").value),
  maxIntensity: 1,  	// Limita qué tan rojo se puede poner
  opacity: 0.5,     	// Más suave
});
function updateHeatmapFromVisibleMarkers() {
  const visibleCoords = markers
    .filter(marker => marker.getVisible())
    .map(marker => marker.getPosition());
  if (visibleCoords.length === 0) {
    // Si no hay franquicias visibles, apagamos el heatmap
    heatmap.setMap(null);
    heatBtn.classList.remove("layer-active");
    return;
  }
  heatmap.setData(visibleCoords);
  // Si estaba apagado, lo encendemos automáticamente
  if (!heatmap.getMap()) {
    heatmap.setMap(map);
    heatBtn.classList.add("layer-active");
  }
}
const heatBtn = document.getElementById("heatmap-toggle");
const heatIconOn = `
  <img
    src="images/icons/heatmap-off.png"
    style="width:25px; height:25px;"
    alt="Heatmap OFF"
  />
  <span>Heatmap OFF</span>
`;

const heatIconOff = `
  <img
    src="images/icons/heatmap.png"
    style="width:25px; height:25px;"
    alt="Heatmap ON"
  />
  <span>Heatmap ON</span>
`;
heatBtn.addEventListener("click", () => {
  const isActive = Boolean(heatmap.getMap());
  if (isActive) {
    heatmap.setMap(null);
    heatBtn.classList.remove("layer-active");
    heatBtn.innerHTML = heatIconOff;
  } else {
    // Antes de pintar, fija el radius correcto en píxeles
    const metros = Number(radiusInput.value);
    heatmap.set("radius", metersToHeatmapRadius(metros));
    updateHeatmapFromVisibleMarkers();
    heatBtn.innerHTML = heatIconOn;
  }
});





// ←———  AÑADE AQUÍ el código del slider ———→
const radiusInput = document.getElementById("heatmap-radius");
const radiusValue = document.getElementById("heatmap-radius-value");
// Inicializa el radius en el heatmap
heatmap.set("radius", Number(radiusInput.value));
// Al mover el slider, actualiza el radius y redibuja si está activo
radiusInput.addEventListener("input", () => {
  const metros = Number(radiusInput.value);
  const px = metersToHeatmapRadius(metros);
  heatmap.set("radius", px);
  radiusValue.textContent = metros;
  if (heatmap.getMap()) updateHeatmapFromVisibleMarkers();
});
/**
 * Convierte un radio en metros a píxeles para Google Maps HeatmapLayer.
 * @param {number} meters   Radio deseado, en metros.
 * @returns {number}        Radio en píxeles para el zoom y lat actual.
 */
 function metersToHeatmapRadius(meters) {
  // Usamos la fórmula de resolución en metros/píxel:
  //   m_per_px = 156543.03392 * cos(lat * π/180) / 2^zoom
  const lat = map.getCenter().lat();
  const zoom = map.getZoom();
  const metersPerPx = 156543.03392 * Math.cos(lat * Math.PI/180) / Math.pow(2, zoom);
  return Math.round(meters / metersPerPx);
}
// ←────────────── Aquí, tras configurar slider y toggle ──────────────
(function(){
  const _origSetVisible = google.maps.Marker.prototype.setVisible;
  google.maps.Marker.prototype.setVisible = function(flag) {
    _origSetVisible.call(this, flag);
    if (heatmap.getMap()) updateHeatmapFromVisibleMarkers();
  };
})();
  map.addListener("click", function (e) {
  if (!researchPinMode) return;
  selectedResearchCoords = e.latLng;
  document.getElementById("research-pin-form").style.display = "block";
});
map.addListener("zoom_changed", () => {
  if (!heatmap.getMap()) return;
  // Recalcula el radio en píxeles y redibuja
  const metros = Number(radiusInput.value);
  heatmap.set("radius", metersToHeatmapRadius(metros));
  updateHeatmapFromVisibleMarkers();
});
// (Opcional) si te preocupa que cambiar el centro mueva la latitud de referencia:
// map.addListener("center_changed", () => { … mismo código … });
 
google.maps.event.addListenerOnce(map, 'idle', () => {
  const typeControl = document.querySelector('[title="Mapa"]')?.parentNode?.parentNode;
  if (typeControl) {
    document.getElementById("menu-button").style.top = (typeControl.offsetTop + typeControl.offsetHeight + 10) + "px";
  }
  const switchEl = document.getElementById("darkModeSwitch");
  if (switchEl) {
    const storedDarkMode = localStorage.getItem("darkMode");
    
    if (storedDarkMode === "true") {
      switchEl.checked = true;
      map.setOptions({ styles: darkMapStyle });
      document.body.classList.add("dark-mode");
    }
    switchEl.addEventListener("change", function () {
      const isDark = this.checked;
      localStorage.setItem("darkMode", isDark ? "true" : "false");
      map.setOptions({ styles: isDark ? darkMapStyle : lightMapStyle });
      document.body.classList.toggle("dark-mode", isDark);
    });
  }
loadResearchPins();
 
document.getElementById("local-pin-toggle").addEventListener("click", () => {
  activatePinMode("add");
});

/**
 * Modo “pin de expansión” SIN colisión con el Custom Pin original
 */
 function activateExpansionPinMode() {
  // 6.1) Ocultar panel y aviso
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
  showToast("📍 Click on the map to place the expansion pin");

  // 6.2) Cursor y limpieza de listeners de click
  map.setOptions({ draggableCursor: "crosshair" });
  google.maps.event.clearListeners(map, "click");

  // 6.3) Nuestro listener SIN usar clickListener ni marker
  const expClickListener = map.addListener("click", function(e) {
    // 🗑️ 6.3.1) Borro el anterior si existía
    if (currentExpansionMarker) {
      currentExpansionMarker.setMap(null);
    }

    // 🎯 6.3.2) Crear marcador de expansión
    const expansionMarker = new google.maps.Marker({
      position: e.latLng,
      map,
      icon: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png'
    });
    currentExpansionMarker = expansionMarker;

    // 6.3.3) Abrir InfoWindow para analizar
    const iw = new google.maps.InfoWindow({
      content: `<button id="expansion-analyze-btn">Analize area</button>`
    });
    iw.open(map, expansionMarker);

google.maps.event.addListenerOnce(iw, 'domready', () => {
  document.getElementById('expansion-analyze-btn')
    .addEventListener('click', () => {
      showLoading();
      runCustomAnalysis(expansionMarker);
      iw.close();
    });
});


    // 6.3.4) Restaurar estado del mapa
    google.maps.event.removeListener(expClickListener);
    map.setOptions({ draggableCursor: null });
  });
}


// Esperamos a que DOM esté listo (puede ir dentro de initMap o al final de <script>):
  document.getElementById('expansion-pin-btn')
  .addEventListener('click', activateExpansionPinMode);

document.getElementById("save-analysis-toggle").addEventListener("click", () => {
    // Siempre actualizamos los datos, pero filtramos las franquicias fuera del círculo
    const pins = markers.filter(m => {
      const franchiseVisible = m.getVisible() && m.__visibleByFranchise;
      const withinCircle = currentCircle
        ? google.maps.geometry.spherical.computeDistanceBetween(
            m.getPosition(),
            currentCircle.getCenter()
          ) <= currentCircle.getRadius()
        : true;
      return franchiseVisible && withinCircle;
    }).map(m => ({
      franchise:   m.franchise,
      address:     m.Address,
      category:    m.category,
      subcategory: m.subcategory,
      operations:  m.Operations,
      location:    m.location
    }));
    const rulerLine = (rulerPolyline && rulerPolyline.getPath().getLength() === 2)
      ? {
          pointA: {
            lat: rulerPolyline.getPath().getAt(0).lat(),
            lng: rulerPolyline.getPath().getAt(0).lng()
          },
          pointB: {
            lat: rulerPolyline.getPath().getAt(1).lat(),
            lng: rulerPolyline.getPath().getAt(1).lng()
          }
        }
      : null;
    const data = {
      date:      new Date().toISOString(),
      center:    currentCircle ? { lat: currentCircle.getCenter().lat(), lng: currentCircle.getCenter().lng() } : null,
      radius:    currentCircle ? currentCircle.getRadius() : null,
      pins,
      rulerLine,
      filters: {
        franchises: markers.filter(m => m.__visibleByFranchise).map(m => m.franchise),
        operations: Array.from(activeOperations),
        nse:        Array.from(activeNSEs),
        locations:  Array.from(activeLocationsFilter),
        filterPanelOpen: document.getElementById("filter-panel").classList.contains("open"),
        traffic:    Array.from(activeAvenues),
        cityBoundaries: Array.from(activeLocations)
      }
    };
    window.pendingAnalysisData = data;
    promptSaveAnalysis();
  });
document.getElementById('toolbar-toggle').addEventListener('click', function(e) {
  const bar = document.getElementById('toolbar');
  if (bar.classList.contains('toolbar-hidden')) {
	bar.classList.remove('toolbar-hidden');
	this.innerText = '▲';
	bar.style.opacity = 1;
  } else {
	bar.classList.add('toolbar-hidden');
	this.innerText = '▼';
	bar.style.opacity = 0.5;
  }
});
 
document.getElementById("ruler-toggle").addEventListener("click", () => {
  const popup = document.getElementById("ruler-popup");
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";
  // 🔄 Reset anteriores
  if (rulerPolyline) {
              	rulerPolyline.setMap(null);
              	rulerPolyline = null;
  }
  if (tempRulerLine) {
              	tempRulerLine.setMap(null);
              	tempRulerLine = null;
  }
  if (tempDistanceLabel) {
              	tempDistanceLabel.close();
              	tempDistanceLabel = null;
  }
  rulerPoints = [];
  // 🔁 Cancela listeners anteriores
  if (rulerListener) {
              	google.maps.event.removeListener(rulerListener);
              	rulerListener = null;
  }
  if (window._rulerMousemoveListener) {
              	google.maps.event.removeListener(window._rulerMousemoveListener);
              	window._rulerMousemoveListener = null;
  }
  showToast("Click on the map to draw a line from A to B");
  map.setOptions({ draggableCursor: "crosshair" });
  // Escucha movimiento del mouse para la línea dinámica
  window._rulerMousemoveListener = map.addListener("mousemove", (e) => {
              	if (rulerPoints.length === 1) {
             	const path = [rulerPoints[0], e.latLng];
             	const distanceMeters = google.maps.geometry.spherical.computeDistanceBetween(
	         	rulerPoints[0], e.latLng
             	);
             	const formatted = distanceMeters >= 1000
	         	? (distanceMeters / 1000).toFixed(2) + " km"
	         	: Math.round(distanceMeters) + " m";
             	if (tempDistanceLabel) {
	         	tempDistanceLabel.setContent(formatted);
	         	tempDistanceLabel.setPosition(e.latLng);
             	} else {
	         	tempDistanceLabel = new google.maps.InfoWindow({
  	      	content: formatted,
  	      	position: e.latLng,
  	      	pixelOffset: new google.maps.Size(0, -20)
	         	});
	         	tempDistanceLabel.open(map);
             	}
             	if (tempRulerLine) {
	         	tempRulerLine.setPath(path);
             	} else {
	         	tempRulerLine = new google.maps.Polyline({
  	      	path: path,
  	      	geodesic: true,
  	      	strokeColor: rulerColor,
  	      	strokeOpacity: 0.5,
  	      	strokeWeight: 4,
  	      	map: map,
  	      	clickable: false,
  	      	zIndex: 100 // ✅ Encima de polígonos
	         	});
             	}
              	}
  });
  // Escucha clics para marcar punto A y B
  rulerListener = map.addListener("click", (e) => {
              	rulerPoints.push(e.latLng);
              	if (rulerPoints.length === 2) {
             	if (tempDistanceLabel) tempDistanceLabel.close();
             	if (tempRulerLine) tempRulerLine.setMap(null);
             	rulerPolyline = new google.maps.Polyline({
	         	path: rulerPoints,
	         	geodesic: true,
	         	strokeColor: rulerColor,
	         	strokeOpacity: 1.0,
	         	strokeWeight: 4,
	         	map: map,
	         	zIndex: 100 // ✅ encima de todo
             	});
             	const distance = google.maps.geometry.spherical.computeDistanceBetween(
	         	rulerPoints[0], rulerPoints[1]
             	) / 1000;
             	document.getElementById("ruler-popup-text").textContent = `Distance: ${distance.toFixed(1)} KM`;
             	popup.style.display = "block";
             	// ✅ Restaurar cursor
             	map.setOptions({ draggableCursor: null });
             	// 🔁 Eliminar listeners
             	google.maps.event.removeListener(rulerListener);
             	google.maps.event.removeListener(window._rulerMousemoveListener);
             	rulerListener = null;
             	window._rulerMousemoveListener = null;
             	rulerPoints = [];
              	}
  });
});
 
loadLocalPins();
map.addListener("click", (e) => {
  if (pinMode === "add") {
              	const name = prompt("Name of your Pin:");
              	if (!name) {
             	showToast("Pin not saved.");
             	pinMode = null;
             	map.setOptions({ draggableCursor: null });
             	return;
              	}
              const position = {
             	lat: e.latLng.lat(),
             	lng: e.latLng.lng()
              	};
              	createLocalMarker(name, position);
              	localPins.push({ name, position });
              	savePinsToStorage();
              	showToast(`Pin saved: ${name}`);
              	pinMode = null;
              	map.setOptions({ draggableCursor: null });
  }
  else if (pinMode === "delete") {
              	// 👇 Cancelar si hizo clic en el mapa sin seleccionar un pin
              	pinMode = null;
              	map.setOptions({ draggableCursor: null });
  }
});
 
 
 
const streetView = map.getStreetView();
streetView.addListener("visible_changed", () => {
  const isVisible       = streetView.getVisible();
  const menuButton      = document.getElementById("menu-button");
  const filterPanel     = document.getElementById("filter-panel");
  const popup           = document.getElementById("popup");
  const popup2          = document.getElementById("popup2");
  const searchBox       = document.getElementById("autocomplete-container");
  const rulerPopup      = document.getElementById("ruler-popup");
  const localPinOptions = document.getElementById("local-pin-options");
  const trafficPanel    = document.getElementById("traffic-panel");
  const cityPanel       = document.getElementById("city-panel");
  const toolBar         = document.getElementById("toolbar");
  const devTool         = document.getElementById("dev-toolbar");
  if (isVisible) {
    // → ENTRAMOS A STREET VIEW: ocultar todo
    if (menuButton)      menuButton.style.display      = "none";
    if (searchBox)       searchBox.style.display       = "none";
    if (toolBar)         toolBar.style.display         = "none";
    if (localPinOptions) localPinOptions.style.display = "none";
    wasRulerPopupVisible   = rulerPopup?.style.display   === "block";
    wasTrafficPanelVisible = trafficPanel?.style.display === "block";
    wasCityPanelVisible    = cityPanel?.style.display    === "block";
    wasPopupVisible        = popup?.style.display        === "block";
    wasPopup2Visible       = popup2?.style.display       === "block";
    wasFilterPanelOpen     = filterPanel.classList.contains("open");
    if (rulerPopup)      rulerPopup.style.display      = "none";
    if (trafficPanel)    trafficPanel.style.display    = "none";
    if (cityPanel)       cityPanel.style.display       = "none";
    if (popup)           popup.style.display           = "none";
    if (popup2)          popup2.style.display          = "none";
    filterPanel.classList.remove("open");
    if (devTool)         devTool.style.display         = "none";
  } else {
    // → SALIMOS DE STREET VIEW: restaurar todo
    if (menuButton)      menuButton.style.display      = "";
    if (searchBox)       searchBox.style.display       = "";
    if (toolBar)         toolBar.style.display         = "";
    if (localPinOptions) localPinOptions.style.display = "";
    if (wasRulerPopupVisible)   rulerPopup.style.display   = "block";
    if (wasTrafficPanelVisible) trafficPanel.style.display = "block";
    if (wasCityPanelVisible)    cityPanel.style.display    = "block";
    if (wasPopupVisible)        popup.style.display        = "block";
    if (wasPopup2Visible)       popup2.style.display       = "block";
    if (wasFilterPanelOpen)     filterPanel.classList.add("open");
    if (devTool)                devTool.style.display      = "";
  }
});
 
}); // ✅ ESTA llave faltaba para cerrar el 'addListenerOnce'
loadPins(() => {
applyAllFilters();
});
loadPolygons();
 
loadLocationPolygons();
 
loadTrafficData();
 
enableCircleDrawing();
 
buildNSEControl();
window.map = map;
}
// ============================================================================================================================== Aqui Comienza la Primer Función:
 
 
// Función para Guardar Pins Personalizados
 
function savePinsToStorage() {
  localStorage.setItem("customPins", JSON.stringify(localPins));
}
function loadLocalPins() {
  const stored = JSON.parse(localStorage.getItem("customPins") || "[]");
  localPins = stored;
  stored.forEach(p => {
              	createLocalMarker(p.name, p.position);
  });
}
function createLocalMarker(name, position) {
  const marker = new google.maps.Marker({
    position,
    map,
    title: name,
    icon: {
      url: "https://static.wixstatic.com/media/805cf6_c60c413bdd6545f78929a4d92196dcd5~mv2.png",
      scaledSize: new google.maps.Size(30, 30)
    },
    zIndex: 99
  });
  marker.isLocal  = true;
  marker.pinName  = name;
  localMarkers.push(marker);
  marker.addListener("click", () => {
    // ya no comprobamos pinMode, siempre preguntamos:
    if (confirm(`Delete Pin? "${name}"?`)) {
      marker.setMap(null);
      playSound("sounds/trash.mp3");
      localPins = localPins.filter(p =>
        p.name !== name ||
        p.position.lat !== position.lat ||
        p.position.lng !== position.lng
      );
      localMarkers = localMarkers.filter(m => m !== marker);
      savePinsToStorage();
      showToast(`Pin deleted: ${name}`);
      // si quieres restaurar cursor o modo, hazlo aquí:
      pinMode = false;
      map.setOptions({ draggableCursor: null });
    }
  });
}
 
 
 
function addGeolocationControl(map) {
 
const controlDiv = document.createElement("div");
 
 
 
 
 
 
 
map.controls[google.maps.ControlPosition.TOP_RIGHT].push(controlDiv);
 
 
 
 
 
 
 
const button = controlDiv.querySelector("button");
 
button.addEventListener("click", () => {
 
if (navigator.geolocation) {
 
navigator.geolocation.getCurrentPosition(
 
 (position) => {
 
   const pos = {
 
              	lat: position.coords.latitude,
 
              	lng: position.coords.longitude,
 
   };
 
   map.setCenter(pos);
 
   map.setZoom(15);
 
 
 
 
 
 
 
 
 
// Elimina marcador anterior si existe
 
if (userLocationMarker) {
 
userLocationMarker.setMap(null);
 
}
 
// Crea marcador nuevo
 
userLocationMarker = new google.maps.Marker({
position: pos,
map: map,
icon: {
path: google.maps.SymbolPath.CIRCLE,
scale: 8,
fillColor: "#ff6600",
fillOpacity: 1,
strokeColor: "white",
strokeWeight: 3,
 
}
 
});
 
 },
 
 () => {
 
   showToast("No se pudo obtener tu ubicación.");
 
 }
 
);
 
} else {
 
showToast("Geolocalización no es soportada por tu navegador.");
 
}
 
});
 
}
 
 
 
 
 
 
 
function loadLocationPolygons() {
  fetch(SHEET_LOCATIONS_URL)
    .then(res => res.text())
    .then(csv => {
      Papa.parse(csv, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          const container = document.getElementById("location-control-content");
          const tooltip = document.getElementById("polygon-tooltip");
          container.innerHTML = "";
          const checkboxes = {};
          results.data.forEach(row => {
            const wkt = row.WKT?.trim();
            const city = row.location?.trim();
            const perimeter = row.PERIMETER?.trim();
            if (!wkt || !city) return;
            try {
              const paths = parseWKTPolygon(wkt);
              const polygon = new google.maps.Polygon({
                paths: paths,
                strokeColor: "#ff6600",
                strokeOpacity: 0.8,
                strokeWeight: 8,
                fillColor: "#888888",
                fillOpacity: fillOpacityLevel,
                zIndex: 98,
                map: null,
                clickable: false
              });
              polygon.customCity = city;
              polygon.customPerimeter = perimeter;
  polygon.addListener("click", (e) => {
  // Mostrar tooltip con contenido
  tooltip.innerHTML = `<strong>${polygon.customCity}</strong><br>Área: ${polygon.customPerimeter} km²`;
  tooltip.style.display = "block";
  // Posicionar el tooltip en pantalla
  const point = e.pixel || fromLatLngToContainerPixel(map, e.latLng);
  tooltip.style.left = `${point.x + 10}px`;
  tooltip.style.top = `${point.y + 10}px`;
  // Limpiar timeout anterior (si existe)
  if (tooltipTimeout) clearTimeout(tooltipTimeout);
  // Ocultar automáticamente después de 3 segundos
  tooltipTimeout = setTimeout(() => {
    tooltip.style.display = "none";
  }, 2000);
});
              // Ocultar tooltip si se hace clic en otro lado
              map.addListener("click", () => {
                tooltip.style.display = "none";
              });
              if (!locationPolygons[city]) locationPolygons[city] = [];
              locationPolygons[city].push(polygon);
            } catch (e) {
              console.warn("Error al procesar ciudad:", e);
            }
          });
          const cities = Object.keys(locationPolygons).sort();
          cities.forEach(city => {
            const label = document.createElement("label");
            label.style.display = "block";
            label.style.marginTop = "12px";
            label.style.marginBottom = "12px";
            label.style.fontSize = "13px";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = false;
            checkboxes[city] = checkbox;
            checkbox.addEventListener("change", () => {
              if (checkbox.checked) {
                activeLocations.add(city);
                locationPolygons[city].forEach(poly => poly.setMap(map));
              } else {
                activeLocations.delete(city);
                locationPolygons[city].forEach(poly => poly.setMap(null));
              }
            });
            label.appendChild(checkbox);
            label.append(" " + city);
            container.appendChild(label);
          });
          document.getElementById("selectAllLocations").onclick = () => {
            cities.forEach(city => {
              checkboxes[city].checked = true;
              activeLocations.add(city);
              locationPolygons[city].forEach(poly => poly.setMap(map));
            });
          };
          document.getElementById("clearAllLocations").onclick = () => {
            cities.forEach(city => {
              checkboxes[city].checked = false;
              activeLocations.delete(city);
              locationPolygons[city].forEach(poly => poly.setMap(null));
            });
          };
        }
      });
    });
}
 
 
function fromLatLngToContainerPixel(map, latLng) {
  const scale = Math.pow(2, map.getZoom());
  const nw = new google.maps.LatLng(
    map.getBounds().getNorthEast().lat(),
    map.getBounds().getSouthWest().lng()
  );
  const worldCoordinateNW = map.getProjection().fromLatLngToPoint(nw);
  const worldCoordinate = map.getProjection().fromLatLngToPoint(latLng);
  return {
    x: Math.floor((worldCoordinate.x - worldCoordinateNW.x) * scale),
    y: Math.floor((worldCoordinate.y - worldCoordinateNW.y) * scale)
  };
}

 
function toggleMenu() {
  playSound("sounds/open.mp3");
 
const panel = document.getElementById("filter-panel");
 
const popup1 = document.getElementById("popup");
 
const menuButton = document.getElementById("menu-button");
 
panel.classList.toggle("open");
 
popup1.classList.toggle("shifted", panel.classList.contains("open"));
 
 
}
 
 
function loadPins(callback) {
  const visibleStates = ["Coahuila", "Nuevo León", "Tamaulipas", "Durango"];
  let totalMarkersAdded = 0;

  function processCSVData(csvText, label) {
    let count = 0;

    Papa.parse(csvText, {
      header: true,
      skipEmptyLines: true,
      complete: results => {
        results.data.forEach(row => {
          const lat = parseFloat(row.Latitude);
          const lng = parseFloat(row.Longitude);
          if (isNaN(lat) || isNaN(lng)) return;

          const state = row.State?.trim();
          if (!visibleStates.includes(state)) return;

          const marker = new google.maps.Marker({
            position: { lat, lng },
            map,
            zIndex: 99,
            visible: false,
            clickable: true,
            title: `${row.Address?.trim() || 'Sin dirección'}`,
            icon: {
              url: row.Icon || "https://maps.google.com/mapfiles/ms/icons/yellow-dot.png",
              scaledSize: new google.maps.Size(30, 32)
            }
          });

          const originalSize = new google.maps.Size(30, 32);
          const hoverSize = new google.maps.Size(45, 48);

          marker.addListener("mouseover", () => {
            marker.setIcon({
              url: row.Icon,
              scaledSize: hoverSize,
            });
          });

          marker.addListener("mouseout", () => {
            marker.setIcon({
              url: row.Icon,
              scaledSize: originalSize
            });
          });

          marker.category     = row.Category?.trim()     || "Uncategorized";
          marker.subcategory  = row.Subcategory?.trim()  || "Uncategorized";
          marker.franchise    = row.Franchise?.trim()    || "Unnamed";
          marker.Operations   = row.Operations?.trim()   || "Unspecified";
          marker.Address      = row.Address?.trim()      || "No address";
          marker.location     = row.Location?.trim()     || "No address";
          marker.state        = row.State?.trim()        || "No address";
          marker.webpage      = row.Webpage?.trim()      || "No address";
          marker.__visibleByFranchise = false;

          markers.push(marker);
          totalMarkersAdded++;
          count++;

          marker.addListener('click', () => {
            if (infoWindow) infoWindow.close();
            const hasAnalysis = analysisCircles.length > 0;

            const tpl = `
              <div style="font-size:12px;">
                <strong>${marker.franchise}</strong><br>
                ${marker.Address}<br>
                <button id="analyze-btn" style="margin-top:8px;">
                  ${hasAnalysis ? 'Redo Ananlysis' : 'Run Analysis'}
                </button>
                ${hasAnalysis ? '<button id="clear-analysis-btn" style="margin-left:8px;">Clear Analysis</button>' : ''}
                <button id="set-base-btn" style="margin-top:8px; margin-left:4px;">
                  Set as base
                </button>
              </div>`;

            infoWindow = new google.maps.InfoWindow({ content: tpl });
            infoWindow.open(map, marker);

            google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
              document.getElementById('analyze-btn')
                .addEventListener('click', () => {
                  performAnalysis(marker);
                  infoWindow.close();
                });

              document.getElementById('set-base-btn')
                .addEventListener('click', () => {
                  setBaseFranchise(marker);
                  infoWindow.close();
                });

              const clearBtn = document.getElementById('clear-analysis-btn');
              if (clearBtn) {
                clearBtn.addEventListener('click', () => {
                  analysisCircles.forEach(c => c.setMap(null));
                  analysisMarkers.forEach(m => m.setMap(null));

                  if (currentExpansionMarker) {
                    currentExpansionMarker.setMap(null);
                    currentExpansionMarker = null;
                  }

                  analysisCircles = [];
                  analysisMarkers = [];
                  infoWindow.close();
                });
              }
            });
          });
        });

        // Mostrar resumen por archivo
        console.log(`Markers found in ${label}:`, count);
      }
    });
  }

  Promise.all([
    fetch(SHEET_PINS1_URL).then(res => res.text()),
    fetch(SHEET_PINS2_URL).then(res => res.text())
  ])
  .then(([csv1, csv2]) => {
    processCSVData(csv1, "SHEET_PINS1");
    processCSVData(csv2, "SHEET_PINS2");

    buildFilterPanelGlobal();
    buildOperationsControl();
    populateSearchIndex();
    setupAutocomplete();
    buildLocationFilter();

    if (typeof callback === "function") callback();
  })
  .catch(err => {
    console.error("❌ Error cargando los CSV de pines:", err);
  });
}

 
 
 
 
function closeRulerPopup() {
 
document.getElementById("ruler-popup").style.display = "none";
 
if (rulerPolyline) {
 
  rulerPolyline.setMap(null);
 
  rulerPolyline = null;
 
}
 
}
 
function loadPolygons() {

  fetch(SHEET_NSE_URL)
    .then(res => res.text())
    .then(csv => {
      Papa.parse(csv, {
        header: true,
        skipEmptyLines: true,
        transformHeader: h => h.trim(),   // opcional: limpia espacios en los nombres de columna
        complete: results => {
          results.data.forEach(row => {
            // 2) Filtrar solo 'Urbana'
            const ambito = row.Ambito?.trim();
            if (ambito !== 'Urbana') return;



            // 4) Tu lógica original para WKT / NSE / VIV / POB
            const wkt = row.WKT?.trim();
            const nse = row.NSE?.trim();
            const pob = parseInt(row.POB, 10) || 0;
            const viv = parseInt(row.VIV, 10) || 0;
            if (!wkt || !nse || !(nse in nseColors)) return;

            try {
              const paths = parseWKTPolygon(wkt);
              const polygon = new google.maps.Polygon({
                paths,
                strokeColor:   nseColors[nse],
                strokeOpacity: 0.35,
                strokeWeight:  1,
                fillColor:     nseColors[nse],
                fillOpacity:   0.3,
                map:           null,
                clickable:     false,
                zIndex:        2,
              });

              polygon.customData = { NSE: nse, POB: pob, VIV: viv };
              polygons.push(polygon);

              if (!nsePolygons[nse]) nsePolygons[nse] = [];
              nsePolygons[nse].push(polygon);

            } catch (e) {
              console.warn("Error al procesar WKT:", e);
            }
          });
            // INSERTA A CONTINUACIÓN este bloque:
    
       // 1) Aplana el objeto nsePolygons a un array único
         window.allNsePolygons = Object.values(nsePolygons).flat();
// 2) Precalcula y guarda su bounding‐box para filtros rápidos
window.allNsePolygons.forEach(poly => {
  const bounds = new google.maps.LatLngBounds();
  poly.getPath().getArray().forEach(pt => bounds.extend(pt));
  poly._bounds = bounds;
});

        }
      });
    })
    .catch(err => console.error("Error al cargar CSV:", err));
}

// Función auxiliar para convertir WKT a array de {lat,lng}
function parseWKTPolygon(wkt) {
  return wkt
    .replace(/^POLYGON\s*\(\(\s*/i, '')
    .replace(/\)\)\s*$/, '')
    .split(/,\s*/)
    .map(pair => {
      const [lng, lat] = pair.split(/\s+/).map(Number);
      return { lat, lng };
    });
}



function parseWKTPolygon(wkt) {
 
return wkt.replace("POLYGON ((", "").replace("))", "")
 
.split(", ").map(coord => {
 
const [lng, lat] = coord.split(" ").map(Number);
 
return { lat, lng };
 
});
 
}
 
 
 
 
 
 
 
function parseWKTLine(wkt) {
 
return wkt.replace("LINESTRING (", "").replace(")", "")
 
.split(",").map(coord => {
 
const [lng, lat] = coord.trim().split(" ").map(Number);
 
return { lat, lng };
 
});
 
}
 

function buildGroupedAvenueControl(data) {
  const container = document.getElementById("avenue-control-content");
  container.innerHTML = "";

  // 1) Iterar por cada estado
  Object.keys(data).sort().forEach(state => {
    const stateDetails = document.createElement("details");
    stateDetails.className = "dropdown";
    stateDetails.open = false;

    // Header de Estado con checkbox
    const stateSummary = document.createElement("summary");
    stateSummary.style.display = "flex";
    stateSummary.style.alignItems = "center";
    stateSummary.style.gap = "6px";

    const stateCheckbox = document.createElement("input");
    stateCheckbox.type = "checkbox";
    stateCheckbox.className = "summary-checkbox";
    stateCheckbox.value = state;

    // Inicializar checked de Estado
    const allStatePolys = [];
    Object.values(data[state]).forEach(typeObj => {
      Object.values(typeObj).forEach(locOrAvenues => {
        if (Array.isArray(locOrAvenues)) {
          allStatePolys.push(...locOrAvenues);
        } else {
          Object.values(locOrAvenues).forEach(arr => allStatePolys.push(...arr));
        }
      });
    });
    stateCheckbox.checked = allStatePolys.length > 0 &&
                           allStatePolys.every(poly => activeAvenues.has(poly.customAvenue));

    const stateLabel = document.createElement("span");
    stateLabel.textContent = state;
    stateLabel.className = "category-label";

    stateSummary.append(stateCheckbox, stateLabel);
    stateDetails.append(stateSummary);

    // Sincronizar Estado ↔ hijos
    const updateStateCheckbox = () => {
      const childCbs = stateDetails.querySelectorAll("input[type=checkbox]:not(.summary-checkbox)");
      const checkedCount = Array.from(childCbs).filter(cb => cb.checked).length;
      stateCheckbox.checked = childCbs.length > 0 && checkedCount === childCbs.length;
    };
    stateCheckbox.addEventListener("change", () => {
      const checked = stateCheckbox.checked;
      stateDetails
        .querySelectorAll("input[type=checkbox]:not(.summary-checkbox)")
        .forEach(cb => {
          cb.checked = checked;
          cb.dispatchEvent(new Event("change"));
        });
    });

    // 2) Dentro de cada estado, iterar por tipo
    Object.keys(data[state]).sort().forEach(type => {
      const typeDetails = document.createElement("details");
      typeDetails.className = "dropdown details-subcategory";
      typeDetails.open = false;

      const typeSummary = document.createElement("summary");
      typeSummary.style.display = "flex";
      typeSummary.style.alignItems = "center";
      typeSummary.style.gap = "10px";

      const typeCheckbox = document.createElement("input");
      typeCheckbox.type = "checkbox";
      typeCheckbox.className = "summary-checkbox";
      typeCheckbox.value = type;

      // Inicializar checked de Tipo
      const allTypePolys = [];
      if (type.toLowerCase() === "urban train") {
        Object.values(data[state][type]).forEach(arr => allTypePolys.push(...arr));
      } else {
        Object.values(data[state][type]).forEach(locObj =>
          Object.values(locObj).forEach(arr => allTypePolys.push(...arr))
        );
      }
      typeCheckbox.checked = allTypePolys.length > 0 &&
                             allTypePolys.every(poly => activeAvenues.has(poly.customAvenue));

      const typeLabel = document.createElement("span");
      typeLabel.textContent = type;
      typeLabel.className = "subcategory-label";

      if (type.toLowerCase() === "urban train" ||
    type.toLowerCase() === "main thoroughfares") {
  typeLabel.style.color = "gray";
}

      typeSummary.append(typeCheckbox, typeLabel);
      typeDetails.append(typeSummary);

      const updateTypeCheckbox = () => {
        const childCbs = typeDetails.querySelectorAll("input[type=checkbox]:not(.summary-checkbox)");
        const checkedCount = Array.from(childCbs).filter(cb => cb.checked).length;
        typeCheckbox.checked = childCbs.length > 0 && checkedCount === childCbs.length;
        updateStateCheckbox();
      };
      typeCheckbox.addEventListener("change", () => {
        const checked = typeCheckbox.checked;
        typeDetails
          .querySelectorAll("input[type=checkbox]:not(.summary-checkbox)")
          .forEach(cb => {
            cb.checked = checked;
            cb.dispatchEvent(new Event("change"));
          });
      });

      // 3a) Rama Urban Train: state > type > avenue[]
      if (type.toLowerCase() === "urban train") {
        Object.keys(data[state][type]).sort().forEach(avenue => {
          const label = document.createElement("label");
          label.style.marginLeft = "15px";
          label.style.fontSize = "12px";
          label.style.display = "block";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = avenue;
          checkbox.checked = data[state][type][avenue]
            .every(poly => activeAvenues.has(poly.customAvenue));

          checkbox.addEventListener("change", () => {
            data[state][type][avenue].forEach(poly => {
              poly.setMap(checkbox.checked ? map : null);
              if (checkbox.checked) activeAvenues.add(poly.customAvenue);
              else activeAvenues.delete(poly.customAvenue);
            });
            updateTypeCheckbox();
          });

          label.append(checkbox, document.createTextNode(" " + avenue));
          typeDetails.append(label);
        });

      // 3b) Resto de tipos: state > type > location > avenue[]
      } else {
        Object.keys(data[state][type]).sort().forEach(location => {
          const locationDetails = document.createElement("details");
          locationDetails.className = "dropdown";
          locationDetails.open = false;

          const locationSummary = document.createElement("summary");
          locationSummary.style.display = "flex";
          locationSummary.style.alignItems = "center";
          locationSummary.style.gap = "20px";

          const locationCheckbox = document.createElement("input");
          locationCheckbox.type = "checkbox";
          locationCheckbox.className = "summary-checkbox";
          locationCheckbox.value = location;

          // Inicializar checked de Location
          const allLocationPolys = Object.values(data[state][type][location]).flat();
          locationCheckbox.checked = allLocationPolys.length > 0 &&
                                     allLocationPolys.every(poly => activeAvenues.has(poly.customAvenue));

          const locationLabel = document.createElement("span");
          locationLabel.textContent = location;
          locationLabel.className = "subcategory-label";

          locationSummary.append(locationCheckbox, locationLabel);
          locationDetails.append(locationSummary);

          const updateLocationCheckbox = () => {
            const cbs = locationDetails.querySelectorAll("input[type=checkbox]:not(.summary-checkbox)");
            const count = Array.from(cbs).filter(cb => cb.checked).length;
            locationCheckbox.checked = cbs.length > 0 && count === cbs.length;
            updateTypeCheckbox();
          };
          locationCheckbox.addEventListener("change", () => {
            const checked = locationCheckbox.checked;
            locationDetails
              .querySelectorAll("input[type=checkbox]:not(.summary-checkbox)")
              .forEach(cb => {
                cb.checked = checked;
                cb.dispatchEvent(new Event("change"));
              });
          });

          Object.keys(data[state][type][location]).sort().forEach(avenue => {
            const label = document.createElement("label");
            label.style.marginLeft = "20px";
            label.style.fontSize = "12px";
            label.style.display = "block";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = avenue;
            checkbox.checked = data[state][type][location][avenue]
              .every(poly => activeAvenues.has(poly.customAvenue));

            checkbox.addEventListener("change", () => {
              data[state][type][location][avenue].forEach(poly => {
                poly.setMap(checkbox.checked ? map : null);
                if (checkbox.checked) activeAvenues.add(poly.customAvenue);
                else activeAvenues.delete(poly.customAvenue);
              });
              updateLocationCheckbox();
            });

            label.append(checkbox, document.createTextNode(" " + avenue));
            locationDetails.append(label);
          });

          typeDetails.append(locationDetails);
        });
      }

      stateDetails.append(typeDetails);
    });

    container.append(stateDetails);
  });
}

</script>
 
<script>
function enableCircleDrawing() {
  const manager = new google.maps.drawing.DrawingManager({
    drawingMode: null,
    drawingControl: false,
    circleOptions: {
      fillColor: circleColor,
      fillOpacity: fillOpacityLevel,
      strokeColor: "#FF0000",
      strokeWeight: 7.5,
      clickable: false,
      editable: false,
      zIndex: 100
    }
  });
  manager.setMap(map);
  google.maps.event.addListener(manager, 'circlecomplete', circle => {
    // 1) Quita el círculo anterior
    if (currentCircle) currentCircle.setMap(null);
    currentCircle = circle;
    circle.setRadius(Math.min(circle.getRadius(), maxCircleRadius));
    // 2) Busca pines (franquicias) dentro del círculo
    currentCircleData = markers.filter(marker => {
      const dist = google.maps.geometry.spherical
        .computeDistanceBetween(circle.getCenter(), marker.getPosition());
      return dist <= circle.getRadius() && marker.getVisible();
    });
    // 3) Comprueba NSE dentro del círculo
    let foundNSE = false;
    for (const nse of activeNSEs) {
      const polys = nsePolygons[nse] || [];
      for (const poly of polys) {
        for (const point of poly.getPath().getArray()) {
          if (google.maps.geometry.spherical
            .computeDistanceBetween(circle.getCenter(), point)
            <= circle.getRadius()) {
            foundNSE = true;
            break;
          }
        }
        if (foundNSE) break;
      }
      if (foundNSE) break;
    }
    const allProps = Object.values(propertyMarkers)
  .reduce((acc, arr) => acc.concat(arr), []);  // aplanamos todos los markers
const propsInCircle = allProps.filter(o => {
  const pos = o.getPosition?.() || o.getCenter?.();
  if (!pos) return false;
  return google.maps.geometry.spherical
    .computeDistanceBetween(circle.getCenter(), pos)
    <= circle.getRadius();
});
    // ────────────────────────────────────────────────────────────────────────────────
    // 4) Si NO hay franquicias, NO hay NSE y NO hay propiedades, quitamos el círculo
    if (currentCircleData.length === 0 && !foundNSE && propsInCircle.length === 0) {
      circle.setMap(null);
      currentCircle = null;
      playSound("sounds/circle_empty.mp3");
      showToast("The radius is empty");
    } else {
      // 5) Si hay al menos uno de los tres, abrimos popup2
      showPopup2FromCircle(circle);
      playSound("sounds/popup.mp3");
    }
    // 6) Salimos del modo dibujo
    manager.setDrawingMode(null);
  });
  document.getElementById("circle-toggle").addEventListener("click", () => {
    const panel = document.getElementById("draw-tools-panel");
    if (panel) panel.style.display = "none";
    manager.setDrawingMode(google.maps.drawing.OverlayType.CIRCLE);
  });
}
 
 
 
 
 
 
 
 
 
 
 
function buildNSEControl() {
 
const container = document.getElementById("nse-control-content");
 
container.innerHTML = "";
 
const group = document.createElement("div");
 
group.className = "nse-checkbox-group";
 
const checkboxes = {};
 
for (const nse of Object.keys(nseColors)) {
 
const label = document.createElement("label");
 
const checkbox = document.createElement("input");
 
checkbox.type = "checkbox";
 
checkbox.checked = false;
 
checkboxes[nse] = checkbox;
 
checkbox.onchange = () => {
 
if (checkbox.checked) {
 
activeNSEs.add(nse);
 
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(map));
 
} else {
 
activeNSEs.delete(nse);
 
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(null));
 
}
 
updatePopupIfCircleExists();
 
};
 
label.appendChild(checkbox);
 
const badge = document.createElement("span");
 
badge.textContent = " " + nse;
 
badge.style.backgroundColor = nseColors[nse];
 
badge.style.color = "white";
 
badge.style.padding = "2px 6px";
 
badge.style.marginLeft = "6px";
 
badge.style.borderRadius = "4px";
 
badge.style.fontSize = "12px";
 
badge.style.fontWeight = "bold";
 
badge.style.display = "inline-block";
 
label.appendChild(badge);
 
group.appendChild(label);
 
}
 
container.appendChild(group);
 
document.getElementById("selectAllNSE").onclick = () => {
 
Object.keys(checkboxes).forEach(nse => {
 
checkboxes[nse].checked = true;
 
activeNSEs.add(nse);
 
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(map));
 
});
 
updatePopupIfCircleExists();
 
};
 
document.getElementById("clearAllNSE").onclick = () => {
 
const checkedCount = Object.values(checkboxes).filter(cb => cb.checked).length;
Object.keys(checkboxes).forEach(nse => {
checkboxes[nse].checked = false;
activeNSEs.delete(nse);
if (nsePolygons[nse]) nsePolygons[nse].forEach(poly => poly.setMap(null));
});
updatePopupIfCircleExists();
};
}


function buildLocationFilter() {
  const container = document.getElementById("location-filter-content");
  container.innerHTML = "";
  container.style.marginTop = "12px";

  const checkboxes = {};
  const stateCheckboxes = {};
  const states = {};

  // 1) Agrupar los markers por estado y luego por location
  markers.forEach(marker => {
    if (!states[marker.state]) {
      states[marker.state] = new Set();
    }
    states[marker.state].add(marker.location);
  });

  // 2) Para cada estado, crear su sección
  Object.entries(states).forEach(([state, locationsSet]) => {
    // Contenedor padre
    const wrapper = document.createElement("div");
    wrapper.style.marginBottom = "8px";

    // Header del estado (label + checkbox + flecha)
    const stateHeader = document.createElement("div");
    stateHeader.style.display = "flex";
    stateHeader.style.alignItems = "center";
    stateHeader.style.justifyContent = "space-between";
    stateHeader.style.cursor = "pointer";
    stateHeader.style.fontSize = "12px";
    stateHeader.style.color = "#f60";
    stateHeader.style.fontWeight = "bold";

    // Checkbox + texto del estado
    const stateLabelWrapper = document.createElement("div");
    stateLabelWrapper.style.display = "flex";
    stateLabelWrapper.style.alignItems = "center";
    stateLabelWrapper.style.gap = "6px";

    const stateCheckbox = document.createElement("input");
    stateCheckbox.type = "checkbox";
    stateCheckbox.value = state;
    stateCheckbox.classList.add("state-checkbox");
    // Inicializar checked si todas las ciudades de este estado están en activeLocationsFilter
    const allCitiesSelected = [...locationsSet].every(loc =>
      activeLocationsFilter.has(loc)
    );
    stateCheckbox.checked = allCitiesSelected;
    stateCheckboxes[state] = stateCheckbox;

    const stateLabel = document.createElement("span");
    stateLabel.textContent = state;

    stateLabelWrapper.append(stateCheckbox, stateLabel);

    const arrow = document.createElement("span");
    arrow.textContent = "▶"; // contraído al inicio

    // Contenedor de las ciudades, oculto inicialmente
    const locationsContainer = document.createElement("div");
    locationsContainer.style.marginLeft = "24px";
    locationsContainer.style.display = "none";
    const groupClass = `group-${state.replace(/\s+/g, "-")}`;
    locationsContainer.classList.add(groupClass);

    // Toggle visibilidad al hacer clic en el header (pero no en el checkbox)
    stateHeader.onclick = () => {
      const isVisible = locationsContainer.style.display !== "none";
      locationsContainer.style.display = isVisible ? "none" : "block";
      arrow.textContent = isVisible ? "▶" : "▼";
    };
    stateCheckbox.onclick = e => e.stopPropagation();

    // Cuando el checkbox de estado cambia, marcar/desmarcar todas sus ciudades
    stateCheckbox.onchange = () => {
      const checked = stateCheckbox.checked;
      locationsSet.forEach(loc => {
        checkboxes[loc].checked = checked;
        if (checked) activeLocationsFilter.add(loc);
        else activeLocationsFilter.delete(loc);
      });
      applyAllFilters();
    };

    // Montar el header
    stateHeader.append(stateLabelWrapper, arrow);
    wrapper.append(stateHeader, locationsContainer);

    // 3) Añadir cada ciudad bajo este estado
    [...locationsSet].sort().forEach(loc => {
      const label = document.createElement("label");
      label.style.display = "block";
      label.style.margin = "6px 0";
      label.style.fontSize = "12px";
      label.style.color = "#000";
      label.style.fontWeight = "500";

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = loc;
      // Inicializar checked según activeLocationsFilter
      checkbox.checked = activeLocationsFilter.has(loc);
      checkboxes[loc] = checkbox;

      checkbox.onchange = () => {
        if (checkbox.checked) {
          activeLocationsFilter.add(loc);
        } else {
          activeLocationsFilter.delete(loc);
        }
        // Sincronizar estado del checkbox de estado padre
        const allChecked = [...locationsSet].every(l => checkboxes[l].checked);
        stateCheckbox.checked = allChecked;
        applyAllFilters();
      };

      label.append(checkbox, document.createTextNode(" " + loc));
      locationsContainer.appendChild(label);
    });

    container.appendChild(wrapper);
  });

  // 4) Botones de "Seleccionar todos" / "Limpiar todos"
  document.getElementById("selectAllLocationsFilter").onclick = () => {
    Object.keys(checkboxes).forEach(loc => {
      checkboxes[loc].checked = true;
      activeLocationsFilter.add(loc);
    });
    Object.values(stateCheckboxes).forEach(cb => cb.checked = true);
    applyAllFilters();
  };

  document.getElementById("clearAllLocationsFilter").onclick = () => {
    Object.keys(checkboxes).forEach(loc => {
      checkboxes[loc].checked = false;
      activeLocationsFilter.delete(loc);
    });
    Object.values(stateCheckboxes).forEach(cb => cb.checked = false);
    applyAllFilters();
  };
}




function buildOperationsControl() {
 
const container = document.getElementById("operations-control-content");
 
container.innerHTML = "";
 
const checkboxes = {};
 
const operationsFound = new Set();
 
markers.forEach(marker => {
 
const op = marker.Operations?.trim() || "Sin operación";
 
operationsFound.add(op);
 
});
 
 
 
 
 
const group = document.createElement("div");
 
group.className = "operations-checkbox-group";
 
Array.from(operationsFound).sort((a, b) => a.localeCompare(b)).forEach(op => {
 
const label = document.createElement("label");
 
const checkbox = document.createElement("input");
 
checkbox.type = "checkbox";
 
checkbox.checked = true;
 
checkboxes[op] = checkbox;
 
checkbox.onchange = () => {
 
if (!checkbox.checked) {
 
const remaining = Array.from(container.querySelectorAll('input[type="checkbox"]'))
 
.filter(cb => cb !== checkbox && cb.checked);
 
if (remaining.length === 0) {
 
checkbox.checked = true;
 
setTimeout(() => {
 
  showToast("There must be at least one operation selected.");
 
}, 10);
 
return;
 
}
 
activeOperations.delete(op);
 
} else {
 
activeOperations.add(op);
 
}
 
updateOperationsFilter();
 
};
 
label.appendChild(checkbox);
 
label.appendChild(document.createTextNode(" " + op));
 
group.appendChild(label);
 
});
 
container.appendChild(group);
 
document.getElementById("selectAllOperations").onclick = () => {
 
Object.keys(checkboxes).forEach(op => {
 
checkboxes[op].checked = true;
 
activeOperations.add(op);
 
});
 
updateOperationsFilter();
 
};
 
}
 
 
 
 
 
 
 
 
 
function updateOperationsFilter() {
 
activeOperations = new Set();
document.querySelectorAll("#operations-control-content input[type=checkbox]").forEach(input => {
if (input.checked) {
const opLabel = input.nextSibling?.textContent?.trim();
if (opLabel) activeOperations.add(opLabel);
}
 
});
 
 
 
 
 
 
 
applyAllFilters();
 
updatePopupIfCircleExists(); // ✅ Esto es lo que faltaba
 
}
 
 
</script>
 
<script>
 
function buildFilterPanelGlobal() {
 
const panel = document.getElementById("pin-control-content");
 
const openDetails = new Set();
 
panel.querySelectorAll("details").forEach(d => {
 
if (d.open) {
 
const label = d.querySelector("summary span")?.textContent;
 
if (label) openDetails.add(label);
 
}
 
});
 
 
 
 
 
panel.innerHTML = "";
 
const grouped = {};
 
 
 
 
 
 
 
 
 
markers.forEach(marker => {
 
const cat = marker.category;
 
const sub = marker.subcategory;
 
const fra = marker.franchise;
 
if (!grouped[cat]) grouped[cat] = {};
 
if (!grouped[cat][sub]) grouped[cat][sub] = {};
 
if (!grouped[cat][sub][fra]) grouped[cat][sub][fra] = [];
 
grouped[cat][sub][fra].push(marker);
 
});
 
 
 
 
 
 
 
const orderedCategories = Object.keys(grouped).sort((a, b) => a.localeCompare(b));
 
for (const cat of orderedCategories) {
 
const catDetails = document.createElement("details");
 
catDetails.className = "dropdown";
 
catDetails.open = openDetails.has(cat);
 
const catSummary = document.createElement("summary");
 
catSummary.innerHTML = "";
 
catSummary.style.display = "flex";
 
catSummary.style.alignItems = "center";
 
catSummary.style.gap = "6px";
 
 
 
const catCheckbox = document.createElement("input");
 
catCheckbox.type = "checkbox";
 
catCheckbox.className = "summary-checkbox";
 
catCheckbox.checked = isCategoryVisible(grouped[cat]);
 
catCheckbox.onchange = () => {
 
const visible = catCheckbox.checked;
 
for (const sub in grouped[cat]) {
 
for (const fra in grouped[cat][sub]) {
 
grouped[cat][sub][fra].forEach(m => {
 
m.__visibleByFranchise = visible;
 
});
 
}
 
}
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
};
 
 
 
 
 
 
 
const catLabel = document.createElement("span");
 
catLabel.textContent = cat;
 
catLabel.className = "category-label";
 
 
 
 
 
 
 
catSummary.appendChild(catCheckbox);
 
catSummary.appendChild(catLabel);
 
catDetails.appendChild(catSummary);
 
 
 
 
 
 
 
const sortedSubcategories = Object.keys(grouped[cat]).sort((a, b) => a.localeCompare(b));
 
 
 
for (const sub of sortedSubcategories) {
 
const subDetails = document.createElement("details");
 
subDetails.className = "dropdown details-subcategory";
 
subDetails.open = openDetails.has(sub);
 
 
 
 
 
 
 
const subSummary = document.createElement("summary");
 
subSummary.innerHTML = "";
 
subSummary.style.display = "flex";
 
subSummary.style.alignItems = "center";
 
subSummary.style.gap = "6px";
 
 
 
 
 
const subCheckbox = document.createElement("input");
 
subCheckbox.type = "checkbox";
 
subCheckbox.className = "summary-checkbox";
 
subCheckbox.checked = isSubcategoryVisible(grouped[cat][sub]);
 
subCheckbox.onchange = () => {
 
const visible = subCheckbox.checked;
 
for (const fra in grouped[cat][sub]) {
 
grouped[cat][sub][fra].forEach(m => {
 
m.__visibleByFranchise = visible;
 
});
 
}
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
};
 
 
 
 
 
 
 
const subLabel = document.createElement("span");
 
subLabel.textContent = sub;
 
subLabel.className = "subcategory-label";
 
 
 
 
 
 
 
subSummary.appendChild(subCheckbox);
 
subSummary.appendChild(subLabel);
 
subDetails.appendChild(subSummary);
 
 
 
 
 
 
 
const sortedFranchises = Object.keys(grouped[cat][sub]).sort((a, b) => a.localeCompare(b));
 
 
 
 
 
 
 
for (const fra of sortedFranchises) {
 
const active = grouped[cat][sub][fra][0].__visibleByFranchise || false;
 
const button = document.createElement("div");
 
button.className = "toggle-btn";
 
if (active) button.classList.add("active");
 
button.textContent = `${fra}`;
 
 
 
 
 
// En el buildFilterPanelGlobal(), dentro de button.onclick, justo después de applyAllFilters() y buildFilterPanelGlobal():

button.onclick = (e) => {
  e.stopPropagation();
  const isNowActive = button.classList.toggle("active");
  grouped[cat][sub][fra].forEach(m => {
    m.__visibleByFranchise = isNowActive;
  });
  applyAllFilters();
  buildFilterPanelGlobal();

  // ③ Si desactivamos la misma franquicia analizada, borramos el análisis:
  if (currentAnalyzedFranchise === fra && !isNowActive) {
    // Borra círculos y marcadores
    analysisCircles.forEach(c => c.setMap(null));
    analysisMarkers.forEach(m => m.setMap(null));
    analysisCircles = [];
    analysisMarkers = [];

    // Cierra el InfoWindow / panel de resultados
    if (typeof closePopup2 === 'function') {
      closePopup2();
    }

    // Resetea la franquicia analizada
    currentAnalyzedFranchise = null;
  }
};

 
 
 
 
 
subDetails.appendChild(button);
 
}
 
 
 
 
 
 
 
 
 
catDetails.appendChild(subDetails);
 
}
 
 
 
panel.appendChild(catDetails);}}
 
 
 
 
 
 
 
function isCategoryVisible(categoryGroup) {
 
for (const sub in categoryGroup) {
 
if (!isSubcategoryVisible(categoryGroup[sub])) return false;
 
}
 
return true;
 
}
 
function isSubcategoryVisible(subGroup) {
 
for (const fra in subGroup) {
 
if (!subGroup[fra][0].getVisible()) return false;
 
}
 
return true;
 
}
 
 
 
 
 
 
 
function selectAllMarkers() {
 
markers.forEach(marker => {
 
marker.__visibleByFranchise = true;
 
});
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
}
 
 
 
 
 
 
 
 
 
function deselectAllMarkers() {
 
markers.forEach(marker => {
 
marker.__visibleByFranchise = false;
 
});
 
applyAllFilters();
 
buildFilterPanelGlobal();
 
}
 
function updatePopupIfCircleExists() {
 
if (currentCircle) {
 
currentCircleData = markers.filter(marker => {
 
const dist = google.maps.geometry.spherical.computeDistanceBetween(currentCircle.getCenter(), marker.getPosition());
 
return dist <= currentCircle.getRadius() && marker.getVisible();
 
});
 
showPopup2FromCircle(currentCircle);
 
}
 
}
 
function downloadExcel() {
  if (!currentCircle) {
    showToast("Dibuja un círculo para descargar datos.");
    return;
  }
  const center = currentCircle.getCenter();
  const radius = currentCircle.getRadius();
  // === HOJA 1: Franquicias ===
  const franchiseData = currentCircleData.map(marker => ({
    Category:    marker.category,
    Subcategory: marker.subcategory,
    Franchise:   marker.franchise,
    Operations:  marker.Operations || "Sin operación",
    Address:     marker.Address   || "Sin dirección"
  }));
  if (franchiseData.length === 0) {
    showToast("No hay franquicias dentro del círculo.");
    return;
  }
  const ws1 = XLSX.utils.json_to_sheet(franchiseData);
  // Función auxiliar ahora devuelve también el array de rows
  function makePropSheet(key, sheetName) {
    const rows = (propertyMarkers[key] || [])
      .filter(m => {
        const pos = m.getPosition?.() || m.getCenter?.();
        return pos &&
          google.maps.geometry.spherical.computeDistanceBetween(pos, center) <= radius;
      })
      .map(m => {
        const p = m._props || {};
        const nombre = p.título    // clave con tilde
                      || p.Nombre
                      || p.nombre
                      || p.titulo
                      || p.Titulo
                      || p.name
                      || p.Name
                      || m.Address
                      || "Sin título";
        return {
          Property: nombre,
          Ticket:   p.precio     ?? "N/A",
          Area:     p.superficie ?? "N/A"
        };
      });
    return {
      sheetName,
      rows,
      sheet: XLSX.utils.json_to_sheet(rows)
    };
  }
  // === HOJAS DE PROPIEDADES ===
  const propSheets = [
    makePropSheet('localesRenta',   'Spaces_Lease'),
    makePropSheet('localesVenta',   'Spaces_Sale'),
    makePropSheet('terrenosRenta',  'Land_Lease'),
    makePropSheet('terrenosVenta',  'Land_Sale')
  ];
  // === HOJA NSE ===
  const nseSummary = {};
  let totalViv = 0;
  for (const poly of polygons) {
    const inside = poly.getPath().getArray().some(pt =>
      google.maps.geometry.spherical.computeDistanceBetween(center, pt) <= radius
    );
    if (!inside) continue;
    const { NSE, VIV } = poly.customData;
    if (!NSE || !activeNSEs.has(NSE)) continue;
    nseSummary[NSE] = (nseSummary[NSE] || 0) + VIV;
    totalViv += VIV;
  }
  const nseRows = Object.entries(nseSummary).map(([nse, viv]) => ({
    NSE:        nse,
    '#Houses':  viv,
    '%': ((viv / totalViv) * 100).toFixed(1) + "%"
  }));
  const nseSheet = {
    sheetName: 'NSE',
    rows:      nseRows,
    sheet:     XLSX.utils.json_to_sheet(nseRows)
  };
  // === Generar y descargar el libro ===
  const wb = XLSX.utils.book_new();
  // Siempre agregamos Franchise_List
  XLSX.utils.book_append_sheet(wb, ws1, "Stores");
  // Solo agregamos NSE si hay datos
  if (nseSheet.rows.length > 0) {
    XLSX.utils.book_append_sheet(wb, nseSheet.sheet, nseSheet.sheetName);
  }
  // Solo agregamos cada hoja de propiedades si tiene al menos 1 fila
  for (const { sheetName, sheet, rows } of propSheets) {
    if (rows.length > 0) {
      XLSX.utils.book_append_sheet(wb, sheet, sheetName);
    }
  }
  window.pendingWorkbook = wb;
  // Mostrar modal para el nombre de archivo
  const modal = document.getElementById("filename-modal2");
  const container = document.fullscreenElement || document.body;
  container.appendChild(modal);
  modal.style.display = "block";
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

function reverseGeocode(latlng, callback) {
  const geocoder = new google.maps.Geocoder();
  geocoder.geocode({ location: latlng }, (results, status) => {
    if (status === "OK" && results.length) {
      // 1) Aplanar todos los componentes de todas las respuestas
      const allComps = results.flatMap(r => r.address_components);
      // 2) Buscar en orden de preferencia
      const cityComp =
        allComps.find(c => c.types.includes("locality")) ||
        allComps.find(c => c.types.includes("postal_town")) ||
        allComps.find(c => c.types.includes("sublocality_level_1")) ||
        allComps.find(c => c.types.includes("administrative_area_level_2")) ||
        allComps.find(c => c.types.includes("administrative_area_level_1"));
      // 3) Fallback al primer fragmento de formatted_address
      const city = cityComp?.long_name
        || results[0].formatted_address.split(",")[0]
        || "Ubicación desconocida";
      callback(city);
    } else {
      console.warn("Geocoder failed:", status);
      callback("Ubicación desconocida");
    }
  });
}



// carga Charts solo una vez
google.charts.load('current',{ packages:['corechart'] });
// cada vez que cambie el select y exista un círculo, redibujar
document.getElementById('category-select')
  .addEventListener('change', () => {
    if (currentCircle) showPopup2FromCircle(currentCircle);
  });
 
  function showPopup2FromCircle(circle) {
    
  
  const center = circle.getCenter();
  const radius = circle.getRadius();
  const km = (radius / 1000).toFixed(1);



// --- Cabecera ---
reverseGeocode(center, (address) => {
  const totalStores = currentCircleData.length;
  const headerEl = document.getElementById('popup2-header');
  let html = `
    <div style="font-size:12px;">
      Radius Analysis: ${km} km - ${address}
    </div>`;
  if (totalStores > 0) {
    html += `
      <div style="font-size:12px; font-weight:normal; margin-top:2px;">
        ${totalStores} store${totalStores === 1 ? '' : 's'} in the radius
      </div>`;
  }
  headerEl.innerHTML = html;
});

  // --- Flags de visibilidad para franquicias, subcategoría y operación (igual que antes) ---
  const hasFranchiseData  = currentCircleData.length > 0;
  const hasSubcatData     = currentCircleData.some(m => !!m.subcategory);
  const hasOperationData  = currentCircleData.some(m => !!m.Operations);
  // --- PROPIEDADES DENTRO DEL CÍRCULO (sólo visibles) ---
  const propertyCats    = ['localesRenta','localesVenta','terrenosRenta','terrenosVenta'];
  const hasPropertyData = propertyCats.some(cat =>
    (propertyMarkers[cat] || []).some(m => {
      // — Sólo marcadores con método getVisible y que estén visibles —
      if (typeof m.getVisible !== 'function' || !m.getVisible()) return false;
      // — Calculamos distancia sólo para visibles —
      const pos = (m.getPosition?.() || m.getCenter?.());
      return pos &&
             google.maps.geometry.spherical
               .computeDistanceBetween(pos, center)
             <= radius;
    })
  );
  // --- CÁLCULO DE VIVIENDAS POR NSE (igual que antes) ---
  const vivPorNSE = {};
  const orderedNSE = [];
  for (const [nse, list] of Object.entries(nsePolygons)) {
    const key = nse.trim();
    if (!activeNSEs.has(key)) continue;
    list.forEach(poly => {
      const inside = poly.getPath().getArray().some(pt =>
        google.maps.geometry.spherical.computeDistanceBetween(pt, center) <= radius
      );
      if (inside) {
        vivPorNSE[key] = (vivPorNSE[key] || 0) + (poly.customData?.VIV || 0);
        if (!orderedNSE.includes(key)) orderedNSE.push(key);
      }
    });
  }
  const hasRealNSEData = orderedNSE.length > 0;
  // --- Mostrar / ocultar secciones según flags ---
  document.getElementById('franchise-section').style.display      = hasFranchiseData   ? '' : 'none';
  document.getElementById('subcategory-section').style.display    = hasSubcatData      ? '' : 'none';
  document.getElementById('operation-section').style.display      = hasOperationData   ? '' : 'none';
  document.getElementById('operation-list-section').style.display = hasOperationData   ? '' : 'none';
  document.getElementById('scatter-section').style.display        = hasPropertyData    ? '' : 'none';
  document.getElementById('nse-section').style.display            = hasRealNSEData     ? '' : 'none';
  document.getElementById('list-section').style.display           = hasFranchiseData   ? '' : 'none';
  // --- Si nada está visible, cerrar popup ---
  if (!(hasFranchiseData || hasSubcatData || hasOperationData || hasPropertyData || hasRealNSEData)) {
    document.getElementById('popup2').style.display = 'none';
    return;
  }
  document.getElementById('popup2').style.display = 'block';


//////////////////////////////////////////////////////////////////////// === SCATTER CHART===  /////////////////////////////////////////////////////////////

const select = document.getElementById('category-select');

function drawScatterFor() {
  if (!currentCircle) return;

  const category = select.value;                 // 'localesRenta', 'localesVenta', etc.
  const center   = currentCircle.getCenter();
  const radius   = currentCircle.getRadius();

  // 1) Filtrar SOLO los markers de la categoría activa, visibles y dentro del círculo
  const overlays = (propertyMarkers[category] || []).filter(o => {
    if (!o.getVisible()) return false;           // respeta Retail Options
    const pos = o.getPosition?.() || o.getCenter?.();
    if (!pos) return false;
    const dist = google.maps.geometry.spherical
      .computeDistanceBetween(pos, center);
    return dist <= radius;
  });
  console.log(`[scatter][${category}] overlays encontrados:`, overlays.length);

  // 2) Generar scatterData
  const scatterData = overlays
    .map((o, i) => {
      const supRaw = o._props?.superficie;
      const preRaw = o._props?.precio;
      if (supRaw == null || preRaw == null) {
        console.warn(`[scatter][${category}][${i}] falta superficie/precio`, o._props);
        return null;
      }
      const sup = Number(String(supRaw).replace(/[^\d.-]/g, ''));
      const pre = Number(String(preRaw).replace(/[^\d.-]/g, ''));
      // rangos por categoría
      let supMin, supMax, preMin, preMax;
      switch (category) {
        case 'localesRenta':
          supMin = 50;    supMax = 350;
          preMin = 5000;  preMax = 250000;
          break;
        case 'localesVenta':
          supMin = 100;     supMax = 1500;
          preMin = 500000;  preMax = 10000000;
          break;
        case 'terrenosRenta':
          supMin = 100;    supMax = 10000;
          preMin = 2000;   preMax = 2000000;
          break;
        case 'terrenosVenta':
          supMin = 100;    supMax = 10000;
          preMin = 500;    preMax = 50000000;
          break;
        default:
          supMin = 0;      supMax = Infinity;
          preMin = 0;      preMax = Infinity;
      }
      if (isNaN(sup) || isNaN(pre) ||
          sup < supMin || sup > supMax ||
          pre < preMin || pre > preMax) {
        return null;
      }
      const valorM2 = pre / sup;
      const tip = `
        <div style="
          background: black;
          color: white;
          padding: 6px 8px;
          border-radius: 4px;
          font-size: 12px;
        ">
          Área: ${sup.toLocaleString(undefined, { maximumFractionDigits: 0 })} m²<br>
          MX$/m²: $${valorM2.toLocaleString(undefined, { maximumFractionDigits: 0 })}
        </div>`;
      return [ sup, valorM2, tip ];
    })
    .filter(r => r);
  console.log(`[scatter][${category}] scatterData length:`, scatterData.length);

  // 3) Construir DataTable
  const table = new google.visualization.DataTable();
  table.addColumn('number', 'Area m²');
  table.addColumn('number', 'MX$/m²');
  table.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
  scatterData.forEach(row => table.addRow(row));

  // 4) Color según categoría
  const colorMap = {
    localesRenta:  '#9999FF',
    localesVenta:  '#9900CC',
    terrenosRenta: '#FF99FF',
    terrenosVenta: '#FF0099'
  };
  const chartColor = colorMap[category] || '#999999';

  // 5) Dibujar ScatterChart
  new google.visualization.ScatterChart(
    document.getElementById('scatterchart')
  ).draw(table, {
    backgroundColor: chartsColor,
    legend:    'none',
    hAxis: {
      title: 'Area m²',
      titleTextStyle: { color: '#ff6600', fontSize: 12, bold: true },
      textStyle:      { color: '#ff6600', fontSize: 12 },
      gridlines:      { color: '#eee' }
    },
    vAxis: {
      title: 'MX$/m²',
      titleTextStyle: { color: '#ff6600', fontSize: 12, bold: true },
      textStyle:      { color: '#ff6600', fontSize: 12 },
      gridlines:      { color: '#eee' }
    },
    pointSize: 2,
    tooltip:   { isHtml: true },
    colors:    [ chartColor ]
  });

  // 6) Resumen
  const summaryEl = document.getElementById('scatter-summary');
  summaryEl.style.fontSize = '12px';
  summaryEl.style.color    = '#ff6600';
  if (scatterData.length) {
    const avgA = scatterData.reduce((s,[a])=>s + a, 0) / scatterData.length;
    const avgV = scatterData.reduce((s,[,v])=>s + v, 0) / scatterData.length;
    summaryEl.innerHTML =
      `# Properties Analyzed: ${scatterData.length}<br>` +
      `Avg. Area: ${avgA.toLocaleString(undefined, { maximumFractionDigits: 0 })} m² — ` +
      `Avg. MX$/m²: $${avgV.toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
  } else {
    summaryEl.textContent = 'No hay datos válidos para el scatter.';
  }
}






  // 8) Cargar Charts UNA sola vez y asignar listener al select
  google.charts.load('current',{packages:['corechart']});
  google.charts.setOnLoadCallback(() => {
    drawScatterFor();
    select.addEventListener('change', drawScatterFor);
  
 
 
const nsePob = {};
const franchiseCount = {};
const subcategoryCount = {};
const operationsCount = {};
const operationsMap = {};
let totalViv = 0;
 
for (const polygon of polygons) {
const path = polygon.getPath().getArray();
 
let inside = false;
 
for (const point of path) {
 
const dist = google.maps.geometry.spherical.computeDistanceBetween(center, point);
 
if (dist <= radius) {
 
inside = true;
 
break;
 
}
 
}
 
if (inside) {
 
const { NSE, POB, VIV } = polygon.customData;
 
if (!NSE || !activeNSEs.has(NSE)) continue;
 
nsePob[NSE] = (nsePob[NSE] || 0) + POB;
 
totalViv += VIV;
 
}
 
}
 
for (const marker of currentCircleData) {
 
const franchise = marker.franchise || "Sin nombre";
 
const subcategory = marker.subcategory || "Sin subcategoría";
 
franchiseCount[franchise] = (franchiseCount[franchise] || 0) + 1;
 
const operation = marker.Operations || "Sin operación";
 
operationsCount[operation] = (operationsCount[operation] || 0) + 1;
 
if (!operationsMap[operation]) operationsMap[operation] = new Set();
 
const address = marker.Address || "Sin dirección";
 
operationsMap[operation].add(address);
 
subcategoryCount[subcategory] = (subcategoryCount[subcategory] || 0) + 1;
 
}
 
//if (
 
//Object.keys(franchiseCount).length === 0 &&
//Object.keys(subcategoryCount).length === 0 &&
//Object.keys(nsePob).length === 0
 
//) {
 
//document.getElementById("popup2").style.display = "none";
 
//return;
 
// }
document.getElementById("popup2-extra").innerText = `Total Houses: ${totalViv.toLocaleString()}`;//
const listContainer = document.getElementById('franchise-list');
listContainer.innerHTML = "";
const grouped = {};
let totalCount = 0;
currentCircleData.forEach(marker => {
  const cat = marker.category || "Sin categoría";
  const sub = marker.subcategory || "Sin subcategoría";
  const fra = marker.franchise || "Sin franquicia";
  const icon = marker.icon.url;
  const page = marker.webpage || "#";    // ← aquí tomamos el campo
  if (!grouped[cat]) {
    grouped[cat] = { total: 0, subcategories: {} };
  }
  if (!grouped[cat].subcategories[sub]) {
    grouped[cat].subcategories[sub] = { total: 0, franchises: {} };
  }
  if (!grouped[cat].subcategories[sub].franchises[fra]) {
    grouped[cat].subcategories[sub].franchises[fra] = {
      count: 0,
      icon,
      webpage: page                   // ← lo guardamos junto al icono
    };
  }
  grouped[cat].total++;
  grouped[cat].subcategories[sub].total++;
  grouped[cat].subcategories[sub].franchises[fra].count++;
  totalCount++;
});
// Ordenar categorías por total descendente
const sortedCategories = Object.entries(grouped).sort((a, b) => b[1].total - a[1].total);
sortedCategories.forEach(([cat, catData]) => {
const catPercent = ((catData.total / totalCount) * 100).toFixed(1);
const catDiv = document.createElement("div");
catDiv.style.marginTop = "10px";
catDiv.style.fontWeight = "bold";
catDiv.style.color = "#ff6600";
catDiv.textContent = `${cat} (${catData.total}) ${catPercent}%`;
listContainer.appendChild(catDiv);
const sortedSubcats = Object.entries(catData.subcategories).sort((a, b) => b[1].total - a[1].total);
sortedSubcats.forEach(([sub, subData]) => {
const subPercent = ((subData.total / catData.total) * 100).toFixed(1);
const subDiv = document.createElement("div");
 
subDiv.style.marginLeft = "15px";
subDiv.style.marginTop = "6px";  // ← Agrega esta línea para más espacio vertical
subDiv.style.fontWeight = "bold";
subDiv.textContent = `${sub} (${subData.total}) ${subPercent}%`;
 
listContainer.appendChild(subDiv);
 
const fraDiv = document.createElement("div");
 
fraDiv.style.marginLeft = "25px";
fraDiv.style.marginBottom = "5px";
 
 
 
const fraList = Object.entries(subData.franchises)
 
.sort((a, b) => b[1].count - a[1].count)
 
.map(([name, { count, icon }]) =>
 
`<img src="${icon}" style="width:16px;vertical-align:middle;margin-right:4px;">${name} (${count})`
 
);
 
fraDiv.innerHTML = fraList.join(", ");
 
listContainer.appendChild(fraDiv);
 
});
 
});
 
 
 
 
 
// Rellenar listado textual de operaciones por dirección
 
const operationListContainer = document.getElementById("operation-list");
operationListContainer.innerHTML = "";
 
Object.entries(operationsMap)
.filter(([op]) => op !== "Free Standings")
.sort((a, b) => a[0].localeCompare(b[0]))
.forEach(([op, addressSet]) => {
 
const cleanedSet = new Set();
addressSet.forEach(addr => {
const trimmed = addr.trim();
if (trimmed) cleanedSet.add(trimmed);
 
});
 
const uniqueAddresses = Array.from(cleanedSet).sort().join(", ");
 
const div = document.createElement("div");
 
div.innerHTML = `<strong>${op}:</strong> ${uniqueAddresses}`;
 
div.style.marginBottom = "10px";
 
operationListContainer.appendChild(div);
 
});
 
//////////////////////////////////////////////////////////////////////// === COLUMN CHART===  /////////////////////////////////////////////////////////////
 
const subData = new google.visualization.DataTable();
 
subData.addColumn('string', 'Subcategoría');
 
subData.addColumn('number', '# Stores');
 
subData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
 
subData.addColumn({ type: 'string', role: 'annotation' });
 
 
 
const sortedSubcategories = Object.entries(subcategoryCount)
 
.sort((a, b) => b[1] - a[1])
 
.slice(0, 5);
 
 
 
const subcategoryColors = [
 
'#ff6600', '#e65c00', '#cc5200', '#b34700', '#993d00',
 
'#803300', '#662900', '#4d1f00', '#331400', '#1a0a00'
 
];
 
let subMax = 0;
 
sortedSubcategories.forEach(([sub, count], index) => {
 
const percent = ((count / currentCircleData.length) * 100).toFixed(1);
 
const tooltip = `
 
  <div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
                <strong>${sub}</strong><br>
 
                ${percent}% (${count} stores)
 
  </div>`;
 
subData.addRow([sub, count, tooltip, String(count)]);
 
if (count > subMax) subMax = count;
 
});
 
 
 
const subChartContainer = document.getElementById('subcategorychart');
 
subChartContainer.innerHTML = "";
 
 
 
if (subData.getNumberOfRows() === 0) {
 
subChartContainer.innerHTML = `
 
  <div style="display:flex; justify-content:center; align-items:center; height:200px; color:#999; font-size:13px; font-family:'Segoe UI', sans-serif;">
 
                No Data
 
  </div>`;
 
} else {
 
const subBarChart = new google.visualization.ColumnChart(subChartContainer);
 
subBarChart.draw(subData, {
backgroundColor: chartsColor,
 
  legend: { position: 'none' },
 
  chartArea: { left: 40, width: '90%', height: '90%' },
 
  vAxis: {
 
                title: '# Stores',
 
                minValue: 0,
 
                maxValue: Math.ceil(subMax * 1.25),
 
                format: '0',
 
                gridlines: { color: '#ccc' },
 
                textStyle: { fontSize: 12 }
 
  },
 
  hAxis: {
 
                textPosition: 'none'
 
  },
 
  tooltip: { isHtml: true },
 
  colors: subcategoryColors.slice(0, sortedSubcategories.length),
 
  annotations: { alwaysOutside: true }
 
});
 
}
 
const subAxisMax = Math.ceil(subMax * 1.25); // Limite del eje vertical +25%

 
//////////////////////////////////////////////////////////////////////// === BAR CHART (FRANCHISE)===  /////////////////////////////////////////////////////////////
const franchiseData = new google.visualization.DataTable();
franchiseData.addColumn('string', 'Franchise');
franchiseData.addColumn('number', '# Stores');
franchiseData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
franchiseData.addColumn({ type: 'string', role: 'annotation' });
franchiseData.addColumn({ type: 'string', role: 'style' });
 
const sortedFranchises = Object.entries(franchiseCount)
.sort((a, b) => b[1] - a[1])
.slice(0, 5);
 
const totalPines = currentCircleData.length;
 
const colorList = [
'#ff6600', '#e65c00', '#cc5200', '#b34700', '#993d00',
'#803300', '#662900', '#4d1f00', '#331400', '#1a0a00'
];
 
let colorIndex = 0;
let maxValue = 0;
 
for (const [name, count] of sortedFranchises) {
const percent = (count / totalPines) * 100;
 
 
 
const tooltip = `
 
  <div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
                <strong>${name}</strong><br>
 
                ${percent.toFixed(1)}% (${count} stores)
 
  </div>`;
 
 
 
const color = colorList[colorIndex % colorList.length];
 
franchiseData.addRow([name, count, tooltip, String(count), `color: ${color}`]);
 
if (count > maxValue) maxValue = count;
 
colorIndex++;
 
}
 
const franchisechart = new google.visualization.BarChart(document.getElementById('franchisechart'));
 
franchisechart.draw(franchiseData, {
backgroundColor: chartsColor,
legend: { position: 'none' },
chartArea: { left: 120, width: '100%', height: '85%'},
tooltip: { isHtml: true },
 
vAxis: {
  textPosition: 'out',
  textStyle: { fontSize: 11, fontWeight: 'bolder', color: chartsTextColor }
},
hAxis: {
  title: '# Stores',
  viewWindow: { max: Math.ceil(maxValue * 1.25) },
  format: '0',
  gridlines: { color: '#ccc' },
  textStyle: { fontSize: 12, color: chartsTextColor },
  titleTextStyle: { fontSize: 12, fontWeight: 'bolder', color: chartsTextColor }
},
annotations: {
  alwaysOutside: true,
  textStyle: {
    fontSize: 12,
    bold: true,
    color: chartsTextColor
  }
}
 
});
 
//////////////////////////////////////////////////////////////////////// === PIE CHART DE OPERACIONES ===  /////////////////////////////////////////////////////////////
 
const operationData = new google.visualization.DataTable();
 
operationData.addColumn('string', 'Operation');
operationData.addColumn('number', '# Stores');
operationData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
 
const sortedOperations = Object.entries(operationsCount)
 
.sort((a, b) => b[1] - a[1])
.slice(0, 10);
 
for (const [op, count] of sortedOperations) {
 
const percent = ((count / totalPines) * 100).toFixed(1);
const tooltip = `
 
<div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
  <strong>${op}</strong><br>
 
  ${percent}% (${count} stores)
 
</div>`;
 
operationData.addRow([op, count, tooltip]);
 
}
 
const operationPie = new google.visualization.PieChart(document.getElementById('operationPieChart'));
 
operationPie.draw(operationData, {
backgroundColor: chartsColor,
legend: 'none',
chartArea: { width: '90%', height: '90%' },
colors: [ '#ff6600', '#e65c00', '#cc5200', '#b34700', '#993d00', '#803300', '#662900', '#4d1f00', '#331400', '#1a0a00'],
tooltip: { isHtml: true } // ✅ ahora sí correcto
});
 
 
////////////////////////////////////////////////////////////////////////     === NSE CHART ===      ///////////////////////////////////////////////////////////////////////
 
 
 
const nseData = new google.visualization.DataTable();
 
nseData.addColumn('string', 'NSE');
nseData.addColumn('number', 'Houses');
nseData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } });
 
const vivPorNSE = {};
const orderedNSE = [];
 
for (const [nse, polygonsList] of Object.entries(nsePolygons)) {
const normalizedNSE = nse.trim(); // muy importante
 
 
if (!activeNSEs.has(normalizedNSE)) continue;
 
for (const poly of polygonsList) {
 
const path = poly.getPath().getArray();
const inside = path.some(point =>
 google.maps.geometry.spherical.computeDistanceBetween(center, point) <= radius
 
);
 
if (inside) {
const viv = poly.customData?.VIV || 0;
 
if (!(normalizedNSE in vivPorNSE)) {
  vivPorNSE[normalizedNSE] = 0;
  orderedNSE.push(normalizedNSE);
}
 
vivPorNSE[normalizedNSE] += viv;
 
}}}
 
for (const nse of orderedNSE) {
 
const viviendas = vivPorNSE[nse];
 
const tooltip = `
 
  <div style="background:black; color:white; padding:6px 8px; border-radius:4px; font-size:12px;">
 
                <strong>${nse}</strong><br>
 
                ${viviendas.toLocaleString()} houses
 
  </div>`;
 
nseData.addRow([nse, viviendas, tooltip]);
}
 
const nseChart = new google.visualization.PieChart(document.getElementById('piechart'));
 
nseChart.draw(nseData, {
backgroundColor: chartsColor,
pieHole: 0.35,
legend: { position: 'none' },
chartArea: { width: '90%', height: '95%' },
colors: orderedNSE.map(nse => nseColors[nse] || '#ccc'),
tooltip: { isHtml: true },
sliceVisibilityThreshold: 0  // <-- esto es lo importante
 
});
 
// Renderizar listado de franquicias
 
});
 
document.getElementById("popup2").style.display = "block";
 
}

</script>
 
<script>
 
</script>
<script>
function applyAllFilters() {
markers.forEach(marker => {
const op = marker.Operations?.trim() || "Sin operación";
const isOpActive = activeOperations.size === 0 || activeOperations.has(op);
const isFranchiseActive = marker.__visibleByFranchise || false;
// ❌ Ya no tomamos en cuenta si está dentro de una ciudad
const isLocationActive = activeLocationsFilter.has(marker.location);
const shouldBeVisible = isFranchiseActive && isOpActive && isLocationActive;
marker.setVisible(shouldBeVisible);
});
if (heatmap.getMap()) {
  updateHeatmapFromVisibleMarkers();
}
updatePopupIfCircleExists?.();
 
}
function isCategoryVisible(categoryGroup) {
 
for (const sub in categoryGroup) {
 
if (!isSubcategoryVisible(categoryGroup[sub])) return false;
 
}
 
return true;
 
}
function isSubcategoryVisible(subGroup) {
for (const fra in subGroup) {
if (!subGroup[fra][0].__visibleByFranchise) return false;
}
return true;
 
}
function selectAllMarkers() {
markers.forEach(marker => {
marker.__visibleByFranchise = true;
 
});
 
applyAllFilters();
buildFilterPanelGlobal();
}
function deselectAllMarkers() {
markers.forEach(marker => {
marker.__visibleByFranchise = false;
 
});
applyAllFilters();
buildFilterPanelGlobal();
// 🔴 Contraer todos los <details>
 
const panel = document.getElementById("pin-control-content");
 
panel.querySelectorAll("details").forEach(d => d.open = false);
 
}
function updatePopupIfCircleExists() {
 
if (currentCircle) {
 
currentCircleData = markers.filter(marker => {
 
const dist = google.maps.geometry.spherical.computeDistanceBetween(
 
currentCircle.getCenter(),
 
marker.getPosition()
 
);
 
return dist <= currentCircle.getRadius() && marker.getVisible();
 
});
 
showPopup2FromCircle(currentCircle);
 
}
 
}
 
document.addEventListener("fullscreenchange", () => {
 
const fs = document.fullscreenElement;
 
const ids = [
"popup", "popup2", "menu-button", "filter-panel","autocomplete-container","city-panel","traffic-panel",
"settings-panel","city-options-panel","retail-options-panel","residential-options-panel","traffic-options-panel","municipios-panel","reports-options-panel","portfolio-options-panel",
"poi-search-box","export-files-panel","import-files-panel","draw-tools-panel",
"ruler-popup","tooltip","filename-modal","filename-modal2","bottom-image-container","toolbar","dev-toolbar","research-pin-form",
];
 
ids.forEach(id => {
const el = document.getElementById(id);
if (!el) return;
 
if (fs) {
 
try {
 
  fs.appendChild(el);
 
} catch (e) {
 
  console.warn(`No se pudo mover ${id} a fullscreen`, e);
 
}
 
} else {
 
try {
 
  document.body.appendChild(el);
 
} catch (e) {
 
  console.warn(`No se pudo restaurar ${id}`, e);
 
}
 
}
 
});
 
 
if (currentCircle && document.getElementById("popup2").style.display === "block") {
 
setTimeout(() => showPopup2FromCircle(currentCircle), 100);
 
}
 
});
 
function closePopup() {
document.getElementById("popup").style.display = "none";
}
 
function closePopup2() {
document.getElementById("popup2").style.display = "none";
 
if (currentCircle) {
currentCircle.setMap(null);
currentCircle = null;
}
 
}
function promptSaveAnalysis() {
  let modal = document.getElementById("filename-modal");
  const input = document.getElementById("filename-input");
  if (!modal) {
	// Si no existe el modal, créalo (por seguridad)
	modal = document.createElement("div");
	modal.id = "filename-modal";
	modal.innerHTML = `
  	<p>Do you want to save the report?</p>
  	<input id="filename-input" type="text" />
  	<div>
    	<button onclick="confirmDownload()">Save Analysis</button>
    	<button onclick="cancelDownload()">Cancelar</button>
  	</div>`;
	document.body.appendChild(modal);
  }
  input.value = "analysis_" + new Date().toISOString().slice(0, 10);
  modal.dataset.mode = "analysis";
  modal.style.display = "block";
  // Asegúrate de que esté en el <body>, no en otro contenedor
  if (!document.body.contains(modal)) {
	document.body.appendChild(modal);
  }
}
 
function confirmDownload() {
 
  const fileName = document.getElementById("filename-input").value.trim();
  const fileName2 = document.getElementById("filename-input2").value.trim();
  if (!fileName) {
	showToast("Por favor ingresa un nombre para el archivo.");
	return;
  }
  const modal = document.getElementById("filename-modal");
  const modal2 = document.getElementById("filename-modal2");
  modal.style.display = "none";
  modal2.style.display = "none";
  // Asegura que el modal sigue en el body (por si se pierde por algún cambio en fullscreen o streetview)
  if (!document.body.contains(modal)) {
	document.body.appendChild(modal);
  }
  if (window.pendingWorkbook) {
	XLSX.writeFile(window.pendingWorkbook, `${fileName2}.xlsx`);
	window.pendingWorkbook = null;
	return;
  }
  if (window.pendingAnalysisData) {
	exportAnalysis(window.pendingAnalysisData);
  }
}
 
 
 
function cancelDownload() {
 
document.getElementById("filename-modal").style.display = "none";
document.getElementById("filename-modal2").style.display = "none";
 
window.pendingWorkbook = null;
 
}
 
 
function loadTrafficData() {
  fetch(SHEET_TRAFFIC)
    .then(res => res.text())
    .then(csv => {
      Papa.parse(csv, {
        header: true,
          transformHeader: h => h.trim().toLowerCase(),  // AHORA: "avenue"
        skipEmptyLines: true,
        complete: results => {
          const tooltip = document.getElementById("tooltip");
          const avenueGrouped = {}; // Agrupar por estado > type > location > avenue
          const polylines = [];

          results.data.forEach(row => {
            const wkt      = row.wkt?.trim();
            const avenue = row.avenue?.trim() || "Unnamed Avenue";
            const type     = row.type?.trim()     || "Main Thoroughfares";
            const location = row.location?.trim() || "Unknown";
            const typeLower = type.toLowerCase();

            if (!wkt || !wkt.startsWith("LINESTRING")) return;

            try {
              const path = parseWKTLine(wkt);

              // 🎨 Color por tipo
              let color = "#ff6600";
              if (typeLower === "urban train")       color = "#ff0000";
              else if (typeLower === "main thoroughfares") color = "#000000";
              else return; // sólo dibujar esos 3 tipos

              const polyline = new google.maps.Polyline({
                path,
                geodesic: true,
                strokeColor: color,
                strokeOpacity: 0.85,
                strokeWeight: 5,
                zIndex: 99,
                map: null
              });

              polyline.customType   = type;
              polyline.customAvenue = avenue;
              if (!window.avenuePolylines) window.avenuePolylines = [];
              window.avenuePolylines.push(polyline);

              // — Agrupar por state > type > location > avenue —
              const stateName = row.state?.trim() || "Unknown State";
              if (!avenueGrouped[stateName])            avenueGrouped[stateName] = {};
              if (!avenueGrouped[stateName][type])      avenueGrouped[stateName][type] = {};

              if (typeLower === "urban train") {
                // state → type → avenue[]
                if (!avenueGrouped[stateName][type][avenue]) 
                  avenueGrouped[stateName][type][avenue] = [];
                avenueGrouped[stateName][type][avenue].push(polyline);
              } else {
                // state → type → location → avenue[]
                if (!avenueGrouped[stateName][type][location]) 
                  avenueGrouped[stateName][type][location] = {};
                if (!avenueGrouped[stateName][type][location][avenue]) 
                  avenueGrouped[stateName][type][location][avenue] = [];
                avenueGrouped[stateName][type][location][avenue].push(polyline);
              }

              // — Tooltip —
              polyline.addListener("mouseover", () => {
                tooltip.style.display = "block";
                tooltip.textContent = avenue;
              });
              polyline.addListener("mousemove", e => {
                const pos = tooltipOverlay
                  .getProjection()
                  .fromLatLngToDivPixel(e.latLng);
                const offsetX = 0, offsetY = -10;
                tooltip.style.left = `${pos.x + offsetX}px`;
                tooltip.style.top  = `${pos.y + offsetY}px`;
              });
              polyline.addListener("mouseout", () => {
                tooltip.style.display = "none";
              });

              polylines.push({ polyline, avenue });
            } catch (e) {
              console.warn("Error al procesar línea:", e);
            }
          });

          buildGroupedAvenueControl(avenueGrouped);
        }
      });
    });

  document.getElementById("selectAllAvenues").onclick = () => {
    document
      .querySelectorAll("#avenue-control-content input[type='checkbox']")
      .forEach(cb => {
        cb.checked = true;
        cb.dispatchEvent(new Event("change"));
      });
  };

  document.getElementById("clearAllAvenues").onclick = () => {
    document
      .querySelectorAll("#avenue-control-content input[type='checkbox']")
      .forEach(cb => {
        cb.checked = false;
        cb.dispatchEvent(new Event("change"));
      });
  };
} 
</script>
 
<div id="toast"></div>
 
<!-- Modal para nombre del archivo MKTS-->
 
<div id="filename-modal" style="display: none;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);background: white;border: 2px solid #ff6600;border-radius: 10px;padding: 20px;z-index: 100000;box-shadow: 0 4px 10px rgba(0,0,0,0.3);text-align: center;font-family: 'Segoe UI', sans-serif;">
 
<p style="margin-bottom: 10px;">Do you want to save the report?:</p>
 
<input id="filename-input" type="text" value="file1" style="padding: 8px;width: 85%;border: 1px solid #ccc;border-radius: 4px;margin-bottom: 15px;font-size: 12px;"/>
 
<div>
 
<button onclick="confirmDownload()" style=" background: #ff6600; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-right: 10px; ">Save Analysis</button>
 
<button onclick="cancelDownload()" style="
background: gray;
color: white;
border: none;
padding: 8px 16px;
border-radius: 5px;
cursor: pointer;
">Cancel</button>
</div>
</div>
<!-- Modal para nombre del archivo EXCEL-->
 
<div id="filename-modal2" style="display: none;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);background: white;border: 2px solid #ff6600;border-radius: 10px;padding: 20px;z-index: 100000;box-shadow: 0 4px 10px rgba(0,0,0,0.3);text-align: center;font-family: 'Segoe UI', sans-serif;">
 
  <p style="margin-bottom: 10px;">Do you want to save the report?:</p>
  
  <input id="filename-input2" type="text" value="file1" style="padding: 8px;width: 85%;border: 1px solid #ccc;border-radius: 4px;margin-bottom: 15px;font-size: 12px;"/>
  
  <div>
  
  <button onclick="confirmDownload()" style="
  
  background: #ff6600;
  
  color: white;
  
  border: none;
  
  padding: 8px 16px;
  
  border-radius: 5px;
  
  cursor: pointer;
  
  margin-right: 10px;
  
  ">Save Analysis</button>
  
  <button onclick="cancelDownload()" style="
  background: gray;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 5px;
  cursor: pointer;
  ">Cancel</button>
  </div>
  </div>
<script>
 
let searchableItems = [];
function populateSearchIndex() {
searchableItems = markers.map(marker => ({
label: `${marker.franchise} - ${marker.Address} - ${marker.location}`, // ← SIN SUBCATEGORÍA
marker: marker
}));
}
function setupAutocomplete() {
 
const input = document.getElementById("search-input");
 
const resultsContainer = document.getElementById("autocomplete-results");
 
input.addEventListener("input", () => {
 
const term = input.value.trim().toLowerCase();
 
resultsContainer.innerHTML = "";
 
if (!term) {
 
  resultsContainer.style.display = "none";
 
  return;
 
}
 
 const matches = searchableItems.filter(item =>
 
  item.label.toLowerCase().includes(term)
 
).slice(0, 100); // Máx. 10 sugerencias
 
 if (matches.length === 0) {
 
  resultsContainer.style.display = "none";
 
  return;
 
}
 
 matches.forEach(match => {
 
  const div = document.createElement("div");
 
  div.textContent = match.label;
 
  div.style.padding = "6px 8px";
 
  div.style.cursor = "pointer";
 
  div.onmouseover = () => {
 
div.style.backgroundColor = "#ff6600";     	// fondo suave
  
div.style.borderRadius = "3px";

div.style.color = "white"; // ⬅️ Fuente en color blanco



 
};
 
div.onmouseout = () => {
 
div.style.backgroundColor = "white";

div.style.color = "black"; // ⬅️ Fuente en color blanco

 
div.style.border = "none";
 
};
 
  div.onclick = () => {
 
              	input.value = "";
 
              	resultsContainer.style.display = "none";
 
              	focusOnMarker(match.marker);
 
              	console.log("Focusing on:", match.marker.franchise);
 
  };
 
  resultsContainer.appendChild(div);
 
});
 
 resultsContainer.style.display = "block";
 
});
 
document.addEventListener("click", (e) => {
 
if (!document.getElementById("autocomplete-container").contains(e.target)) {
 
  resultsContainer.style.display = "none";
}
});
}
function focusOnMarker(marker) {
const franchiseName = marker.franchise;
const subcategory = marker.subcategory;
const category = marker.category;
// 1. Activa todos los marcadores de esa franquicia
markers.forEach(m => {
if (m.franchise === franchiseName) {
m.__visibleByFranchise = true;
m.setVisible(true);
}
});
// 2. Expande el panel jerárquico y activa el botón de la franquicia
const pinPanel = document.getElementById("pin-control-content");
const categoryDetails = Array.from(pinPanel.querySelectorAll("details.dropdown"))
.find(d => d.querySelector("summary span")?.textContent === category);
if (categoryDetails) {
categoryDetails.open = true;
const subcategoryDetails = Array.from(categoryDetails.querySelectorAll("details.dropdown"))
.find(d => d.querySelector("summary span")?.textContent === subcategory);
if (subcategoryDetails) {
subcategoryDetails.open = true;
const franchiseButton = Array.from(subcategoryDetails.querySelectorAll(".toggle-btn"))
  .find(btn => btn.textContent.includes(franchiseName));
if (franchiseButton && !franchiseButton.classList.contains("active")) {
  franchiseButton.classList.add("active");
}
}
}
// 3. Reaplica filtros y reconstruye el panel
applyAllFilters();
buildFilterPanelGlobal();
// 4. Centra y abre popup del marcador principal buscado
map.setCenter(marker.getPosition());
map.setZoom(17);
const content = `
<div style="font-size:13px;">
<strong>${marker.franchise}</strong><br>
${marker.Address}<br>
${marker.subcategory} – ${marker.Operations}
</div>`;
const infoWindow = new google.maps.InfoWindow({ content });
infoWindow.open(map, marker);
}
function closeAllPanelsAndPopups() {
const trafficPanel = document.getElementById("traffic-panel");
const cityPanel = document.getElementById("city-panel");
// Guarda visibilidad para restaurar en fullscreen
trafficPanel.dataset.wasVisible = trafficPanel.style.display === "block";
cityPanel.dataset.wasVisible = cityPanel.style.display === "block";
trafficPanel.style.display = "none";
cityPanel.style.display = "none";
document.getElementById("autocomplete-container").style.display = "none";
const popup = document.getElementById("popup");
const popup2 = document.getElementById("popup2");
if (popup) popup.style.display = "none";
if (popup2) popup2.style.display = "none";
}
// Botón de Traffic Generators
document.getElementById("traffic-toggle").addEventListener("click", () => {
  // Antes de mostrar Generators, desactiva Live y Historic
  deactivateAllTrafficLayers();
  const panel = document.getElementById("traffic-panel");
  const toggle = document.getElementById("traffic-toggle");
  const wasVisible = panel.style.display === "block";
  closeAllPanelsAndPopups();
  if (!wasVisible) {
    panel.style.display = "block";
    toggle.classList.add("active-toggle");
  } else {
    toggle.classList.remove("active-toggle");
  }
});
// Botón de lupa
document.getElementById("search-toggle").addEventListener("click", (e) => {
const container = document.getElementById("autocomplete-container");
const wasVisible = container.style.display === "block";
closeAllPanelsAndPopups();
if (!wasVisible) container.style.display = "block";
e.stopPropagation();
});
document.getElementById("reset-button").addEventListener("click", () => {
  if (confirm("Sure you want to restart? Any unsaved changes will be lost.")) {
	// 🔁 Limpia el localStorage si usas preferencias almacenadas
localStorage.removeItem("customPolygons");
localStorage.removeItem("customPins");
localStorage.removeItem("importedKMZ");
localStorage.removeItem("researchPins");
localStorage.removeItem("excelData");
localStorage.removeItem("portfolioSheetURL");
location.reload();
}
});
// 📌 Botón para mostrar ubicación actual del usuario
document.getElementById("pin-toggle").addEventListener("click", () => {
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(
              	(position) => {
 const pos = {
lat: position.coords.latitude,
lng: position.coords.longitude,
};
map.setCenter(pos);
map.setZoom(15);
// Elimina marcador anterior si ya existe
if (userLocationMarker) {
userLocationMarker.setMap(null);
}
// Agrega un nuevo marcador en la ubicación actual
userLocationMarker = new google.maps.Marker({
position: pos,
map: map,
icon: {
path: google.maps.SymbolPath.CIRCLE,
scale: 8,
fillColor: "#ff6600",
fillOpacity: 1,
strokeColor: "white",
strokeWeight: 3,
},
});
},
() => {
             	showToast("No se pudo obtener tu ubicación.");
              	}
  );
} else {
  showToast("Geolocalización no es soportada por tu navegador.");
}
});
// Cerrar autocomplete si haces click fuera
document.addEventListener("click", (e) => {
const container = document.getElementById("autocomplete-container");
const toggle = document.getElementById("search-toggle");
if (!container.contains(e.target) && !toggle.contains(e.target)) {
  container.style.display = "none";
}
});
document.addEventListener("fullscreenchange", () => {
const fs = document.fullscreenElement;
const ids = [
"popup", "popup2", "menu-button", "filter-panel","city-panel","traffic-panel",
"autocomplete-container","local-pin-options","poi-search-box","export-files-panel","import-files-panel","notes-panel","reports-options-panel","portfolio-options-panel",
"settings-panel","city-options-panel","retail-options-panel","residential-options-panel","traffic-options-panel","draw-tools-panel","municipios-panel",
"ruler-popup","tooltip","filename-modal","filename-modal2","bottom-image-container","toolbar","research-pin-form","dev-toolbar",
];
// Mover elementos al nuevo contenedor (fullscreen o body)
ids.forEach(id => {
  const el = document.getElementById(id);
 
  if (!el) return;
  try {
              	(fs || document.body).appendChild(el);
  } catch (e) {
              	console.warn(`No se pudo mover ${id}`, e);
  }
});
// 🔁 Restaurar visibilidad de panels de tráfico y ciudades
const trafficPanel = document.getElementById("traffic-panel");
const cityPanel = document.getElementById("city-panel");
if (trafficPanel.dataset.wasVisible === "true") {
trafficPanel.style.display = "block";
document.getElementById("traffic-toggle").classList.add("active-toggle");
} else {
document.getElementById("traffic-toggle").classList.remove("active-toggle");
}
if (cityPanel.dataset.wasVisible === "true") {
cityPanel.style.display = "block";
document.getElementById("city-toggle").classList.add("active-toggle");
} else {
document.getElementById("city-toggle").classList.remove("active-toggle");
}
// 🔄 Restaurar popups si había un círculo activo
if (currentCircle && document.getElementById("popup2").style.display === "block") {
 setTimeout(() => showPopup2FromCircle(currentCircle), 100);
}
});
function closeTrafficPanel() {
document.getElementById('traffic-panel').style.display = 'none';
document.getElementById("traffic-toggle").classList.remove("active-toggle");
if (currentCircle && currentCircleData.length > 0) {
document.getElementById("popup2").style.display = "block";
}
}
function closeCityPanel() {
document.getElementById('city-panel').style.display = 'none';
document.getElementById("city-toggle").classList.remove("active-toggle");
if (currentCircle && currentCircleData.length > 0) {
document.getElementById("popup2").style.display = "block";
 }
}
 
function activatePinMode() {
  const panel = document.getElementById("draw-tools-panel");
  if (panel) panel.style.display = "none";  
  showToast("Click on the Map to add a Custom Marker.");
  map.setOptions({ draggableCursor: "crosshair" });
  // Remueve listeners previos si existen
  google.maps.event.clearListeners(map, "click");
  const clickListener = map.addListener("click", function (e) {
    const name = prompt("¿Marker Name?");
    if (!name) return;
    const position = {
      lat: e.latLng.lat(),
      lng: e.latLng.lng(),
    };
    playSound("sounds/bubble.mp3");
    const icon = {
      url: "https://static.wixstatic.com/media/805cf6_c60c413bdd6545f78929a4d92196dcd5~mv2.png",
      scaledSize: new google.maps.Size(30, 30)
    };
    const marker = new google.maps.Marker({
      title: name,
      position,
      map,
      animation: google.maps.Animation.DROP,
      draggable: true,
      icon,
    });
    marker.addListener("click", () => {
      const confirmDelete = confirm(`Delete Marker "${name}"?`);
      if (confirmDelete) {
        marker.setMap(null);
        playSound("sounds/trash.mp3");
        localPins = localPins.filter(p => p.name !== name || p.position.lat !== position.lat || p.position.lng !== position.lng);
        savePinsToStorage();
      }
    });
    // Guardar en memoria local
    localPins.push({ name, position, icon });
    savePinsToStorage();
    // ✅ Salir del modo pin
    google.maps.event.removeListener(clickListener);
    map.setOptions({ draggableCursor: null });
    showToast("Marker Succesful Saved!");
  });
}
const darkModeBtn = document.getElementById("dark-mode");
darkModeBtn.addEventListener("click", () => {
  const isDark = document.body.classList.toggle("dark-mode");
  rulerColor = isDark ? "#FF6600" : "#000000";
// Cambiar colores de los polígonos importados desde KMZ

    drawnPolygons.forEach(polygon => {
    polygon.setOptions({
      strokeColor: isDark ? "#FF6600" : "#000000",
      fillColor: isDark ? "#FF6600" : "#000000",
      fillOpacity: 0.25,
    });
  });

  customPolygons.forEach(polygon => {
    polygon.setOptions({
      strokeColor: isDark ? "#FF6600" : "#000000",
      fillColor: isDark ? "#FF6600" : "#000000",
      fillOpacity: fillOpacityLevel,
    });
  });
  Object.keys(locationPolygons).forEach(city => {
  locationPolygons[city].forEach(polygon => {
    polygon.setOptions({
      strokeColor: isDark ? '#FFFFFF' : '#ff6600',
      fillColor: isDark ? '#ff6600' : '#000000',      
      fillOpacity: isDark ? 'fillOpacityLevel' : 'fillOpacityLevel'
    });

  window.excelPolygons.forEach(polygon => {
    polygon.setOptions({
      strokeColor: isDark ? '#FFFFFF' : '#ff6600',
      fillColor: isDark ? '#ff6600' : '#000000',      
      fillOpacity: isDark ? 'fillOpacityLevel' : 'fillOpacityLevel'
    });
  });
    
  });
});
  if (window.avenuePolylines) {
  avenuePolylines.forEach(polyline => {
    const type = polyline.customType.toLowerCase();
    let newColor = "#ff6600"; // default
    if (type === "urban train") {
      newColor = isDark ? "#FF7777" : "#ff0000";
    } else if (type === "highways") {
      newColor = isDark ? "#CCCCCC" : "#333333";
    } else if (type === "main thoroughfares") {
      newColor = isDark ? "#FEF4E8" : "#000000";
    }
    polyline.setOptions({ strokeColor: newColor });
  });
}
  // Cambiar el estilo del mapa
  map.setOptions({
	styles: isDark ? darkMapStyle : null
  });
  
  // Guardar la preferencia en localStorage
  localStorage.setItem("darkMode", isDark ? "true" : "false");
});
// Restaurar el modo oscuro si ya estaba activado
window.addEventListener("DOMContentLoaded", () => {
  const stored = localStorage.getItem("darkMode");
  const icon = document.getElementById("dark-mode-icon");
  if (stored === "true") {
    document.body.classList.add("dark-mode");
    if (map) map.setOptions({ styles: darkMapStyle });
    // Cambiar el ícono a bombilla (modo claro)
    icon.src = "https://img.icons8.com/?size=60&id=59810&format=png";
    icon.alt = "Light Mode";
  }
});
document.getElementById("dark-mode").addEventListener("click", () => {
  isDarkMode = !isDarkMode;
  const icon = document.getElementById("dark-mode-icon");
  if (isDarkMode) {
    map.setOptions({ styles: darkMapStyle });
    document.body.classList.add("dark-mode");
    icon.src = "https://img.icons8.com/?size=60&id=59810&format=png"; // 💡 (modo claro)
    icon.alt = "Light Mode";
  } else {
    map.setOptions({ styles: lightMapStyle });
    document.body.classList.remove("dark-mode");
    icon.src = "https://img.icons8.com/?size=60&id=59841&format=png"; // 🌙 (modo oscuro)
    icon.alt = "Dark Mode";
  }
  localStorage.setItem("darkMode", isDarkMode ? "true" : "false");
});
window.addEventListener("load", () => {
  const storedDarkMode = localStorage.getItem("darkMode") === "true";
  if (storedDarkMode) {
    document.getElementById("dark-mode").click(); // Simula toggle
  }
});



window.addEventListener("DOMContentLoaded", () => {
  document.getElementById("pins-research").addEventListener("click", () => {
	map.setOptions({ draggableCursor: "crosshair" }); // 👈 cambia cursor
    researchPinMode = true;
  });
});

function closeResearchPinForm() {
  document.getElementById("research-pin-form").style.display = "none";
  researchPinMode = false;
  selectedResearchCoords = null;
  map.setOptions({ draggableCursor: null }); // ✅ volver a cursor normal
}





function parseWKT(wkt) {
  const match = wkt.match(/POINT\s*\(\s*([-\d\.]+)\s+([-\d\.]+)\s*\)/i);
  if (!match) return null;
  return { lng: parseFloat(match[1]), lat: parseFloat(match[2]) };
}

let poiVisible = false; // estado inicial
document.getElementById("activate-poi").addEventListener("click", () => {
  poiVisible = !poiVisible;
  const currentType = map.getMapTypeId();
  if (poiVisible && currentType === google.maps.MapTypeId.SATELLITE) {
    map.setMapTypeId(google.maps.MapTypeId.HYBRID);
    setTimeout(() => {
      map.setOptions({ styles: getPoiStyle(true) });
    }, 100);
  } else if (!poiVisible && currentType === google.maps.MapTypeId.HYBRID) {
    map.setOptions({
      styles: null // desactiva los estilos
    });
    setTimeout(() => {
      map.setMapTypeId(google.maps.MapTypeId.SATELLITE);
    }, 100);
  } else {
    map.setOptions({ styles: getPoiStyle(poiVisible) });
  }
  // 🔄 Actualizar ícono
  const poiIcon2 = document.getElementById("activate-poi");
  poiIcon2.src = poiVisible
    ? "images/icons/poi-off.png" // OFF
    : "images/icons/poi-on.png"; // ON
  poiIcon2.alt = poiVisible ? "POI ON" : "POI OFF";
});
function getPoiStyle(show) {
  if (show) {
    // Obtenemos el estilo base actual
    const baseStyle = isDarkMode ? darkMapStyle : lightMapStyle;
    // Estilos para mostrar POIs
    const poiStyles = [
      { featureType: "poi", stylers: [{ visibility: "on" }] },
      { featureType: "poi.attraction", stylers: [{ visibility: "on" }] },
      { featureType: "poi.business", stylers: [{ visibility: "on" }] },
      { featureType: "poi.government", stylers: [{ visibility: "on" }] },
      { featureType: "poi.medical", stylers: [{ visibility: "on" }] },
      { featureType: "poi.place_of_worship", stylers: [{ visibility: "on" }] },
      { featureType: "poi.school", stylers: [{ visibility: "on" }] },
      { featureType: "poi.sports_complex", stylers: [{ visibility: "on" }] },
      { featureType: "poi.restaurant", stylers: [{ visibility: "on" }] }
    ];
    // Devolvemos la combinación
    return [...baseStyle, ...poiStyles];
  } else {
    // Restablecemos al estilo original sin POIs
    return isDarkMode ? darkMapStyle : lightMapStyle;
  }
}
async function searchPlacesByText(query) {
  const bounds = map.getBounds();
  if (!bounds) return [];
  const center = bounds.getCenter();
  const ne = bounds.getNorthEast();
  const radius = google.maps.geometry.spherical.computeDistanceBetween(center, ne);
  const response = await fetch("https://places.googleapis.com/v1/places:searchText", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Goog-Api-Key": "AIzaSyBimPrRAY6NuxHcucxTpZ5hxW39CDnvnLM",
      "X-Goog-FieldMask": "places.location,places.displayName"
    },
    body: JSON.stringify({
      textQuery: query,
      maxResultCount: 50,
      locationBias: {
        circle: {
          center: {
            latitude: center.lat(),
            longitude: center.lng()
          },
          radius: radius
        }
      }
    })
  });
  if (!response.ok) {
    const error = await response.text();
    console.error("Error al buscar:", error);
    alert("You are too far from the search range. Zoom in and try again");
    return [];
  }
  const data = await response.json();
  return data.places || [];
}
function renderPOIMarkers(places) {
  poiMarkers.forEach(m => m.setMap(null));
  poiMarkers = [];
  for (const place of places) {
    const position = {
      lat: place.location.latitude,
      lng: place.location.longitude
    };
    const marker = new google.maps.Marker({
      position,
      map,
      title: place.displayName?.text || "POI"
    });
    poiMarkers.push(marker);
  }
  if (places.length > 0) {
    map.setCenter({
      lat: places[0].location.latitude,
      lng: places[0].location.longitude
    });
  } else {
    alert("Coincidences not found!");
  }
  console.log("Places encontrados:", places.length, places);
}
const devToggleButton = document.getElementById("dev-mode");
const devToolbar = document.getElementById("dev-toolbar");
let devPasswordValidated = localStorage.getItem("devPasswordValidated") === "true";
let devToolbarVisible   = devPasswordValidated;
if (devPasswordValidated) {
  devToolbar.style.display = "flex";
  devToolbarVisible = true;
}
// Al hacer click, pide contraseña sólo si no está validada
devToggleButton.addEventListener("click", () => {
  if (!devPasswordValidated) {
    const password = prompt("Admin Password:");
    if (password === "mkts2007") {
      devPasswordValidated = true;
      // Almacena la validación
      localStorage.setItem("devPasswordValidated", "true");
      devToolbar.style.display = "flex";
      devToolbarVisible = true;
    } else if (password !== null) {
      alert("Wrong Password.");
    }
  } else {
    // Si ya validó previamente, sólo alterna la vista
    devToolbarVisible = !devToolbarVisible;
    devToolbar.style.display = devToolbarVisible ? "flex" : "none";
  }
});
////////////////////////////////////////////////////////////     Sound Functions     ////////////////////////////////////////////////////////////////////////////////
function playSound(src) {
  if (!isSoundEnabled) return;
  const audio = new Audio(src);
  audio.play();
}
document.getElementById("sound-toggle").addEventListener("click", () => {
  isSoundEnabled = !isSoundEnabled;
  localStorage.setItem('soundEnabled', isSoundEnabled);
  updateSoundButton();
});
function updateSoundButton() {
  const btn = document.getElementById("sound-toggle");
  const iconUrl = isSoundEnabled
    ? "https://img.icons8.com/?size=48&id=iWO20ZvCeU53&format=png" // sonido ON
    : "https://img.icons8.com/?size=48&id=J8AUGZ0QFMe0&format=png"; // sonido OFF
  btn.innerHTML = `<img src="${iconUrl}" alt="sound-toggle" style="width:20px; height:20px;">`;
}
navigator.storage.estimate().then(({ usage, quota }) => {
  // puedes condicionarte aquí: if (usage + nuevoItemSize > quota) { … }
});
///////////////////////////////////////////////////////////<!-- === Toggle de categorías y botón Todos === -->
 
    document.addEventListener('DOMContentLoaded', () => {
      // Lista de nombres de categoría que usan tus markers
      const categories = [
        'localesRenta',
        'localesVenta',
        'terrenosRenta',
        'terrenosVenta'
      ];
      // Obtener referencias al botón y a los 4 checkboxes
      const toggleAllBtn = document.getElementById('toggle-all-properties');
      const checkboxes = categories.map(cat =>
        document.getElementById(
          `toggle-${cat.replace(/([A-Z])/g, '-$1').toLowerCase()}`
        )
      );
      // Cada checkbox: muestra/oculta los markers de su categoría
      checkboxes.forEach(cb => {
        cb.addEventListener('change', () => {
          const cat = cb.dataset.cat; // e.g. "localesRenta"
          markers.forEach(marker => {
            if (marker.category === cat) {
              marker.setVisible(cb.checked);
            }
          });
        });
      });
      // Botón "Mostrar/Ocultar Todos"
      toggleAllBtn.addEventListener('click', () => {
        const allChecked = checkboxes.every(cb => cb.checked);
        checkboxes.forEach(cb => {
          cb.checked = !allChecked;
          // Disparamos el evento change para que se actualice el mapa
          cb.dispatchEvent(new Event('change'));
        });
      });
    });
    function deactivateAllTrafficLayers() {
  // 1) apaga Live Traffic
  if (trafficLayer) {
    trafficLayer.setMap(null);
  }
  // 2) apaga Historic Traffic y resetea su bandera
  if (trafficPolylineList && trafficPolylineList.length) {
    trafficPolylineList.forEach(poly => poly.setMap(null));
    trafficPolylineList = [];
    trafficIsVisible = false;
  }
  // 3) apaga Traffic Generators (tu lógica previa)
  const genPanel = document.getElementById("traffic-panel");
  if (genPanel.style.display === "block") {
    genPanel.style.display = "none";
    document.getElementById("traffic-toggle").classList.remove("active-toggle");
  }
  document.querySelectorAll("#avenue-control-content input[type='checkbox']").forEach(cb => {
    if (cb.checked) {
      cb.checked = false;
      cb.dispatchEvent(new Event("change"));
    }
  });
}
 

///////////////////////////////////////////////////////////  HOT SPOT  ///////////////////////////////////////////////////////////

// RADIO y ESPACIADO para el grid de candidatos (en metros)
const GRID_RADIUS = 25000;   // 30 km
const GRID_SPACING = 200;    // cada 250 m

// ─────────────────────────────────────────────────────────────────────────
// Función optimizada para métricas de viviendas y NSE
// ─────────────────────────────────────────────────────────────────────────
// Función getMetrics optimizada e integrada con tu variable `polylines`

function getMetrics(center, radius) {
  // 1) Prefiltro rectangular con el bounds del círculo
  const circleBounds = new google.maps.Circle({ center, radius }).getBounds();

  // 2) Viviendas y conteo por NSE
  let totalVIV = 0;
  const nseCounts = {};

  for (const poly of window.allNsePolygons) {
    if (!circleBounds.intersects(poly._bounds)) continue;

    // Chequeo fino: centro dentro o algún vértice dentro del radio
    let inside = false;
    if (google.maps.geometry.poly.containsLocation(center, poly)) {
      inside = true;
    } else {
      for (const pt of poly.getPath().getArray()) {
        if (
          google.maps.geometry.spherical.computeDistanceBetween(pt, center) <=
          radius
        ) {
          inside = true;
          break;
        }
      }
    }
    if (!inside) continue;

    const viv = poly.customData?.VIV || 0;
    totalVIV += viv;
    const nse = poly.customData?.NSE || "Desconocido";
    nseCounts[nse] = (nseCounts[nse] || 0) + viv;
  }

  // 3) Top 2 NSE más predominantes
  const topNSEs = Object.entries(nseCounts)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 2)
    .map(([nse]) => nse);

  // 4) Distancias a avenidas principales (ya tienes tu array `polylines`)
const roadLines = window.avenuePolylines
  .filter(pl => pl.customType.toLowerCase() === "main thoroughfares")
  .map(pl => ({ polyline: pl, avenue: pl.customAvenue }));
  if (!roadLines.length) {
    console.warn(
      'No encontré líneas “Main Thoroughfares”. Revisa tu CSV en la columna `type`.'
    );
  }
  const roadDists = roadLines
    .map(({ polyline, avenue }) => {
          console.log('🛣️ roadLines entry:', { customAvenue: polyline.customAvenue, avenue });

      // Distancia mínima del centro a cualquier punto de la polyline
      const dist = polyline
        .getPath()
        .getArray()
        .reduce((min, pt) => {
          const d = google.maps.geometry.spherical.computeDistanceBetween(
            pt,
            center
          );
          return Math.min(min, d);
        }, Infinity);
      return { name: avenue || "Sin nombre", dist };
    })
    .sort((a, b) => a.dist - b.dist)
    .slice(0, 3);
    console.log('🗺️ roadDists final:', roadDists);


  // 5) Devuelve todas las métricas
  return {
    totalVIV,
    nseCounts,
    topNSEs,
    roadDists,
  };
}
// ─────────────────────────────────────────────────────────────────────────


/**
 * Redondea el centro a la rejilla de spacing (en metros),
 * de modo que cualquier clic dentro de ±spacing/2
 * caiga en el mismo punto de anclaje.
 */
 function snapToGrid(latlng, spacing) {
  const R = 6371000; // radio Tierra en metros
  const lat = latlng.lat();
  const lng = latlng.lng();

  // conversión aproximada metro→grado
  const degPerMeterLat = 1 / 111320;
  const degPerMeterLng = 1 / (111320 * Math.cos(lat * Math.PI/180));

  const latStep = spacing * degPerMeterLat;
  const lngStep = spacing * degPerMeterLng;

  const snappedLat = Math.round(lat / latStep) * latStep;
  const snappedLng = Math.round(lng / lngStep) * lngStep;

  return new google.maps.LatLng(snappedLat, snappedLng);
}


/**
 * Genera un array de LatLng espaciados cada `spacing` metros dentro de un círculo
 * de radio `gridRadius` alrededor de `center`.
 */
 function generateGrid(center, gridRadius = GRID_RADIUS, spacing = GRID_SPACING) {
  // 1) Calcula bounds rectangulares que abarcan el círculo
  const nePoint = google.maps.geometry.spherical.computeOffset(center, gridRadius, 45);
  const swPoint = google.maps.geometry.spherical.computeOffset(center, gridRadius, 225);
  const bounds = new google.maps.LatLngBounds(swPoint, nePoint);

  // 2) Determina pasos en grados
  const latStep = spacing / 111000;
  const centerLat = center.lat() * Math.PI / 180;
  const lngStep = spacing / (111000 * Math.cos(centerLat));

  // 3) Itera dentro del rectángulo, filtrando por distancia al centro
  const pts = [];
  for (let lat = bounds.getSouthWest().lat(); lat <= bounds.getNorthEast().lat(); lat += latStep) {
    for (let lng = bounds.getSouthWest().lng(); lng <= bounds.getNorthEast().lng(); lng += lngStep) {
      const pt = new google.maps.LatLng(lat, lng);
      if (google.maps.geometry.spherical.computeDistanceBetween(center, pt) <= gridRadius) {
        pts.push(pt);
      }
    }
  }
  return pts;
}

// performAnalysis con prompts y spinner + timer
// ——————————————————————————————————————————————

async function performAnalysis(marker) {
  console.log('▶ performAnalysis disparado para:', marker.franchise);

  /* tus prompts… */
  const km        = parseFloat(prompt('Radius (km):', maxCircleRadius/1000));
  const radius    = (isNaN(km) ? maxCircleRadius/1000 : km) * 1000;
  const numResults= parseInt(prompt('¿Cuántos candidatos mostrar?', '3'), 10) || 3;
  const threshold = parseInt(prompt('Umbral (0–100):', '85'), 10) || 85;

  showLoading();

  // Aquí esperamos a que termine ANALYZE asincrónico
  await analyzeFranchise(
  marker.franchise,
  marker.getPosition(),
  radius,
  numResults,
  threshold
);

  hideLoading();
}

// ─────────────────────────────────────────────────────────────────────────
// Versión optimizada de isUrban usando bounds pre-calculados
function isUrban(latLng) {
  // Recorre solo los polígonos que puedan contener el punto, por su _bounds
  for (const poly of window.allNsePolygons) {
    if (!poly._bounds.contains(latLng)) continue;
    // Si el punto cae realmente dentro del polígono, devolvemos true
    if (google.maps.geometry.poly.containsLocation(latLng, poly)) {
      return true;
    }
  }
  return false;
}


/**
 * Versión asíncrona de analyzeFranchise con chunking para no bloquear el hilo UI.
 * Reemplaza tu antigua función por ésta (mismo nombre, mismos parámetros).
 */
// ——————————————————————————————————————————————
// Helpers para el timer
// ——————————————————————————————————————————————

/**
 * Formatea un entero de segundos a "MM:SS"
 */
 function formatMMSS(totalSeconds) {
  const m = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
  const s = String(totalSeconds % 60).padStart(2, "0");
  return `${m}:${s}`;
}

function switchToCountdown(totalSeconds) {
  clearInterval(loadingInterval);
  const timerEl = document.getElementById("loading-timer");
  const elapsed = Math.floor((Date.now() - loadingStartTime) / 1000);
  let remaining = totalSeconds - elapsed;
  if (remaining < 0) remaining = 0;
  timerEl.textContent = formatMMSS(remaining);
  loadingInterval = setInterval(() => {
    remaining--;
    if (remaining < 0) {
      clearInterval(loadingInterval);
      timerEl.textContent = "00:00";
      return;
    }
    timerEl.textContent = formatMMSS(remaining);
  }, 1000);
}


// Función principal ASÍNCRONA con estimación de countdown
async function analyzeFranchise(
  franchiseName,
  center,
  radius,
  numResults,
  threshold = 85,
  baseMetricsOverride = null
) {
  // ① Guarda franquicia y loggea
  currentAnalyzedFranchise = franchiseName;
  console.log('▶ analyzeFranchiseAsync:', { franchiseName, radius, numResults, threshold });

  const NSE_MIN_RELATIVE_RATIO = 0.3;

  // 1) Limpia previos
  analysisCircles.forEach(c => c.setMap(null));
  analysisMarkers.forEach(m => m.setMap(null));
  analysisCircles = [];
  analysisMarkers = [];

  // 2) Dibuja círculo principal
  const mainCircle = new google.maps.Circle({
    center, radius, map,
    strokeColor: '#FF6600', strokeOpacity: 0.7, strokeWeight: 2,
    fillColor: '#FFA500', fillOpacity: 0.1, zIndex: 3
  });
  analysisCircles.push(mainCircle);

  // 3) Métricas base
  const baseMetrics = baseMetricsOverride || getMetrics(center, radius);
  const avgBaseRoad = baseMetrics.roadDists.length
    ? baseMetrics.roadDists.reduce((sum, r) => sum + r.dist, 0) / baseMetrics.roadDists.length
    : 0;
  const [bN1 = 'N/A', bN2 = 'N/A'] = baseMetrics.topNSEs;
  const bPerc1 = baseMetrics.totalVIV
    ? (baseMetrics.nseCounts[bN1] || 0) / baseMetrics.totalVIV
    : 0;
  const bPerc2 = baseMetrics.totalVIV
    ? (baseMetrics.nseCounts[bN2] || 0) / baseMetrics.totalVIV
    : 0;

  // 4) InfoWindow “Original”
  const baseTpl = `
    <div style="font-size:12px;line-height:1.3;">
      <strong>${franchiseName} (Original)</strong><br>
      NSE #1: ${bN1} (${(bPerc1*100).toFixed(1)}%)<br>
      NSE #2: ${bN2} (${(bPerc2*100).toFixed(1)}%)<br>
      Av1 (${baseMetrics.roadDists[0]?.name||'N/A'}): ${(baseMetrics.roadDists[0]?.dist/1000||0).toFixed(2)} km<br>
      Av2 (${baseMetrics.roadDists[1]?.name||'N/A'}): ${(baseMetrics.roadDists[1]?.dist/1000||0).toFixed(2)} km<br>
      Av3 (${baseMetrics.roadDists[2]?.name||'N/A'}): ${(baseMetrics.roadDists[2]?.dist/1000||0).toFixed(2)} km<br>
      Housing: ${baseMetrics.totalVIV}<br><br>
      vivScore: 100%<br>roadScore: 100%<br>nseScore: 100%<br>totalScore: 100%
    </div>`;
  const baseIw = new google.maps.InfoWindow({ content: baseTpl, position: center });
  mainCircle.addListener('click', () => baseIw.open(map));

  // 5) Genera grid y filtra canibalismo/urbanización
  const gridCenter   = snapToGrid(center, GRID_SPACING);
  const grid         = generateGrid(gridCenter, GRID_RADIUS, GRID_SPACING);
  const brandMarkers = markers.filter(m => m.franchise === franchiseName);
  const empties      = grid.filter(pt =>
    brandMarkers.every(mk =>
      google.maps.geometry.spherical.computeDistanceBetween(mk.getPosition(), pt) >= 2 * radius
    )
  );
  const urbanEmpties = empties.filter(isUrban);

  console.log('– grid.total pts:', grid.length);
  console.log('– empties:', empties.length);
  console.log('– urbanEmpties:', urbanEmpties.length);

  const totalPoints = urbanEmpties.length;

  // 7) Marca inicio real de procesamiento
  const t0 = Date.now();

  // 8) Scoring en CHUNKS para no bloquear el hilo
  const scored = [];
  const CHUNK  = 50;
  for (let i = 0; i < totalPoints; i += CHUNK) {
    const slice = urbanEmpties.slice(i, i + CHUNK);
    slice.forEach(pt => {
      const m = getMetrics(pt, radius);
      m.topNSEs = [bN1, bN2];
      const cPerc1 = m.totalVIV ? (m.nseCounts[bN1] || 0) / m.totalVIV : 0;
      const cPerc2 = m.totalVIV ? (m.nseCounts[bN2] || 0) / m.totalVIV : 0;
      if (cPerc1 < bPerc1 * NSE_MIN_RELATIVE_RATIO || cPerc2 < bPerc2 * NSE_MIN_RELATIVE_RATIO)
        return;
      const vivScore = baseMetrics.totalVIV
        ? (m.totalVIV >= baseMetrics.totalVIV
            ? 100
            : 100 - Math.abs(baseMetrics.totalVIV - m.totalVIV) / baseMetrics.totalVIV * 100)
        : 100;
      const avgCandRoad = m.roadDists.length
        ? m.roadDists.reduce((sum, r) => sum + r.dist, 0) / m.roadDists.length
        : 0;
      const roadScore = (avgBaseRoad && avgCandRoad)
        ? Math.min(avgBaseRoad, avgCandRoad) / Math.max(avgBaseRoad, avgCandRoad) * 100
        : 0;
      const totalBasePerc = bPerc1 + bPerc2 || 1;
      const w1 = bPerc1 / totalBasePerc;
      const w2 = bPerc2 / totalBasePerc;
      const score1 = bPerc1 > 0 ? Math.min(cPerc1 / bPerc1, 1) : 0;
      const score2 = bPerc2 > 0 ? Math.min(cPerc2 / bPerc2, 1) : 0;
      const nseScore = (score1 * w1 + score2 * w2) * 100;
      const totalScore = Math.round(vivScore * 0.5 + nseScore * 0.3 + roadScore * 0.2);

      scored.push({ pt, m, vivScore, roadScore, nseScore, score: totalScore });
    });
    // cede al event loop
    await new Promise(res => setTimeout(res, 0));
  }

  // 9) Mide tiempo total y actualiza promedio
  const elapsed = Date.now() - t0;
  avgMsPerPoint  = elapsed / totalPoints;

  console.log('– scored:', scored.map(s => s.score));

  // 11) Filtra, ordena y evita canibalismo entre candidatos
  const filtered = scored
    .filter(x => x.score >= threshold && x.m.totalVIV > 0)
    .sort((a, b) => {
      if (b.vivScore !== a.vivScore) return b.vivScore - a.vivScore;
      if (b.nseScore !== a.nseScore) return b.nseScore - a.nseScore;
      return b.roadScore - a.roadScore;
    });

// 12) Sin canibalismo entre candidatos
const suggestions = [];
  for (const cand of filtered) {
    const ok = suggestions.every(sel =>
      google.maps.geometry.spherical.computeDistanceBetween(sel.pt, cand.pt) >= 2 * radius
    );
    if (ok) {
      suggestions.push(cand);
      if (suggestions.length >= numResults) break;
    }
  }
  console.log('– propuestas finales:', suggestions.map(s => s.score));
  showToast(`Analysis executed: ${suggestions.length} candidates found.`);

  // 13) Pintar resultados en el mapa
  suggestions.forEach(({ pt, m, vivScore, roadScore, nseScore, score }, idx) => {
    const [a1 = {}, a2 = {}, a3 = {}] = m.roadDists;
    // Marker
    const mk = new google.maps.Marker({
      position: pt,
      map,
      icon: {
        url: 'https://community.wacom.com/en-de/wp-content/uploads/sites/20/2023/10/Flame_GIF_1.gif',
        scaledSize: new google.maps.Size(64, 64),
        labelOrigin: new google.maps.Point(30, -10)
      },
      label: {
        text: `${score}%`,
        color: '#FFFFFF',
        fontWeight: 'bold',
        fontSize: '12px'
      },
      title: `#${idx + 1} – Match ${score}%`
    });
    analysisMarkers.push(mk);

    // Circle
    const circ = new google.maps.Circle({
      center: pt,
      radius,
      map,
      strokeColor: '#ff6600',
      strokeOpacity: 0.85,
      strokeWeight: 3,
      fillColor: '#000000',
      fillOpacity: 0.5,
      clickable: false,
      zIndex: 3
    });
    analysisCircles.push(circ);

    // Barra NSE comparativa
    const [n1 = 'N/A', n2 = 'N/A'] = m.topNSEs;
    const p1 = m.totalVIV ? (m.nseCounts[n1] || 0) / m.totalVIV : 0;
    const p2 = m.totalVIV ? (m.nseCounts[n2] || 0) / m.totalVIV : 0;
    const rel1 = bPerc1 > 0 ? Math.min(p1 / bPerc1, 2) * 100 : 0;
    const rel2 = bPerc2 > 0 ? Math.min(p2 / bPerc2, 2) * 100 : 0;
    const p1Display = (p1 * 100).toFixed(1);
    const p2Display = (p2 * 100).toFixed(1);

const tpl = `
  <div style="width:260px; padding:8px; font-size:12px; line-height:1.4;">
    <div style="text-align:center; font-size:14px; font-weight:bold; margin-bottom:6px;">
      Match: ${score}%
    </div>
    <hr style="margin:6px 0 10px 0;">

    <strong>Candidato #${idx + 1}</strong><br>
    Av1 (${a1.name || 'N/A'}): ${(a1?.dist ? (a1.dist / 1000).toFixed(2) : 'N/A')} km<br>
    Av2 (${a2.name || 'N/A'}): ${(a2?.dist ? (a2.dist / 1000).toFixed(2) : 'N/A')} km<br>
    Av3 (${a3.name || 'N/A'}): ${(a3?.dist ? (a3.dist / 1000).toFixed(2) : 'N/A')} km<br>
    Viviendas: ${m.totalVIV}

    <div style="margin-top:12px;">
      <strong style="display:block; margin-bottom:8px;">NSE comparativo vs base:</strong>

      <div style="display:flex; justify-content:space-around; align-items:center;">

        <!-- NSE 1 -->
        <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
          <div style="font-size:11px; margin-bottom:4px;">${n1}</div>
          <div style="display:flex; gap:4px; align-items:flex-end; height:80px; margin-bottom:4px;">
            <div title="Candidato" style="width:16px; background:#28a745; height:${p1Display*1.25}%;"></div>
            <div title="Base" style="width:16px; background:#888; height:${(bPerc1 * 100*1.25).toFixed(1)}%;"></div>
          </div>
          <div style="font-size:11px;">
            ${p1Display}% vs base ${(bPerc1 * 100).toFixed(1)}%
          </div>
        </div>

        <!-- NSE 2 -->
        <div style="text-align:center; display:flex; flex-direction:column; align-items:center;">
          <div style="font-size:11px; margin-bottom:4px;">${n2}</div>
          <div style="display:flex; gap:4px; align-items:flex-end; height:80px; margin-bottom:4px;">
            <div title="Candidato" style="width:16px; background:#28a745; height:${p2Display*1.25}%;"></div>
            <div title="Base" style="width:16px; background:#888; height:${(bPerc2 * 100*1.25).toFixed(1)}%;"></div>
          </div>
          <div style="font-size:11px;">
            ${p2Display}% vs base ${(bPerc2 * 100).toFixed(1)}%
          </div>
        </div>

      </div>
    </div>

    <hr style="margin:12px 0;">
    <div style="font-size:12px;">
      vivScore: ${vivScore.toFixed(1)}%<br>
      roadScore: ${roadScore.toFixed(1)}%<br>
      nseScore: ${nseScore.toFixed(1)}%<br>
      totalScore: ${score}%
    </div>
  </div>
`;

const iw = new google.maps.InfoWindow({ content: tpl });
mk.addListener('click', () => iw.open(map, mk));
  });






  // Opcional: devolver las sugerencias si las necesitas en quien llama
  return suggestions;
}


/**
Lanza analyzeFranchise con las métricas guardadas
 */
 async function runCustomAnalysis(pinMarker) {
  if (!baseFranchiseParams) {
    return alert("❗ Primero selecciona una franquicia base con “Establecer como base”.");
  }

  // ① Arranca spinner y countdown de 60 s
  showLoading();

  // ② Ejecuta el análisis y espera a que termine
  const {
    franchiseName,
    radius,
    numResults,
    threshold,
    baseMetrics
  } = baseFranchiseParams;

  await analyzeFranchise(
    franchiseName,
    pinMarker.getPosition(),
    radius,
    numResults,
    threshold,
    baseMetrics
  );

  // ③ Para el countdown y oculta el loading screen
  hideLoading();
}


let loadingStartTime;
let loadingInterval;

function showLoading() {
  const timerEl = document.getElementById("loading-timer");
  document.getElementById("loading-screen").style.display = "flex";
  loadingStartTime = Date.now();
  clearInterval(loadingInterval);
  // → Siempre countdown de 60 s
  switchToCountdown(60);
}

function hideLoading() {
  document.getElementById("loading-screen").style.display = "none";
  clearInterval(loadingInterval);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

document.getElementById("export-research").addEventListener("click", () => {
 // 1) Leer todos los datos del localStorage
 const storedPins     = JSON.parse(localStorage.getItem("researchPins")   || "[]");
 const customPins     = JSON.parse(localStorage.getItem("customPins")     || "[]");
 const importedKMZ    = JSON.parse(localStorage.getItem("importedKMZ")    || '{"pins":[],"polygons":[]}');
 const customPolygons = JSON.parse(localStorage.getItem("customPolygons") || "[]");
 const excelData      = JSON.parse(localStorage.getItem("excelData") || "{}");
 const rows           = Object.values(excelData).flat();


 // 2) Normalizar Excel → excelPins y excelPolygons
 const excelPins = [];
 const excelPolygons = [];


 rows.forEach(row => {
   const lat = row.position?.lat ?? row.lat ?? row.Lat ?? row.latitude ?? row.Latitude;
   const lng = row.position?.lng ?? row.lng ?? row.Lng ?? row.longitude ?? row.Longitude;


   // Si tiene lat/lng → Marker
   if (!isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng))) {
     excelPins.push({
       name: row.name || row.Name || row.location || row.Location || "",
       position: { lat: parseFloat(lat), lng: parseFloat(lng) },
       icon: row.icon || {}
     });
     return;
   }


   // Si tiene paths (array de puntos lat/lng) → Polígono
   const paths = row.paths || row.Paths || row.path || row.coordinates;
   if (Array.isArray(paths) && paths.length > 2 && paths[0].lat !== undefined && paths[0].lng !== undefined) {
     excelPolygons.push({
       name: row.name || row.Name || "Polygon",
       paths
     });
     return;
   }


   // Si tiene WKT → Polígono
   if (row.WKT || row.wkt) {
     const wkt = row.WKT || row.wkt;
     excelPolygons.push({
       name: row.name || row.Name || "Polygon",
       wkt
     });
   }
 });


 // 3) Verificar que haya contenido
 if (
   storedPins.length === 0 &&
   excelPins.length === 0 &&
   customPins.length === 0 &&
   importedKMZ.pins.length === 0 &&
   customPolygons.length === 0 &&
   excelPolygons.length === 0 &&
   importedKMZ.polygons.length === 0
 ) {
   return alert("Can't Download Empty Files!");
 }


 // 4) Crear libro de Excel
 const workbook = XLSX.utils.book_new();


 if (storedPins.length) {
   const ws1 = XLSX.utils.json_to_sheet(storedPins);
   XLSX.utils.book_append_sheet(workbook, ws1, "Research");
 }


 // 5) Unificar y exportar todos los pins
 const allPins = [
   ...excelPins,
   ...customPins.map(p => ({
     name: p.name || "",
     position: { lat: p.position.lat, lng: p.position.lng },
     icon: p.icon || {}
   })),
   ...importedKMZ.pins.map(p => ({
     name: p.name || "",
     position: { lat: p.position.lat, lng: p.position.lng },
     icon: p.icon || {}
   }))
 ];


 if (allPins.length) {
   const sheetData = allPins.map(p => ({
     name: p.name,
     lat:  p.position.lat,
     lng:  p.position.lng,
     icon: JSON.stringify(p.icon)
   }));
   const wsPins = XLSX.utils.json_to_sheet(sheetData);
   XLSX.utils.book_append_sheet(workbook, wsPins, "Markers");
 }


 // 6) Unificar y exportar polígonos
 const customPolys = customPolygons.map(p => ({
   name: p.name || p.paths?.name || "",
   paths: Array.isArray(p.paths) ? p.paths : Array.isArray(p.paths?.paths) ? p.paths.paths : []
 }));


 const importedPolys = importedKMZ.polygons.map(p => ({
   name: p.name || "",
   paths: Array.isArray(p.paths) ? p.paths : Array.isArray(p.paths?.paths) ? p.paths.paths : []
 }));


 const excelPolys = excelPolygons.map(p => {
   if (p.paths) {
     return { name: p.name, paths: p.paths };
   } else if (p.wkt) {
     return { name: p.name, wkt: p.wkt };
   }
   return null;
 }).filter(p => p !== null);


 const allPolys = [...customPolys, ...importedPolys, ...excelPolys];


 if (allPolys.length > 0) {
   const wktRows = [["name", "WKT"]];
   allPolys.forEach(({ name, paths, wkt }) => {
     if (wkt) {
       wktRows.push([name, wkt]);
     } else if (Array.isArray(paths) && paths.length > 2) {
       const coords = paths.map(pt => `${pt.lng} ${pt.lat}`);
       if (coords[0] !== coords[coords.length - 1]) coords.push(coords[0]);
       const wktString = `POLYGON((${coords.join(", ")}))`;
       wktRows.push([name, wktString]);
     }
   });


   if (wktRows.length > 1) {
     const wsPolys = XLSX.utils.aoa_to_sheet(wktRows);
     XLSX.utils.book_append_sheet(workbook, wsPolys, "Polygons");
   }
 }


 // 7) Guardar archivo
 const fileName = prompt("Enter the name for the Excel file:", "Market_Spots_Geodata");
 if (!fileName) return alert("Export cancelled.");
 XLSX.writeFile(workbook, `${fileName}.xlsx`);
});



async function sendResearchPins() {
  const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzPvAKk8Db8dFTxPNvwhjBhA0aIPomGJl60RNC2gSq7JSLd312sIlvS3H0wpodE1Z0ljA/exec';

  // 1) Leer localStorage
  const raw = JSON.parse(localStorage.getItem('researchPins') || '[]');
  if (!Array.isArray(raw) || raw.length === 0) {
    alert('No hay registros en localStorage.researchPins');
    return;
  }

const mapped = raw.map(p => ({
  Franchise:  p.Franchise  ?? '',
  Operations: p.Operations ?? '',
  Address:    p.Address    ?? '',
  Location:   p.Location   ?? '',
  Latitude:   p.Latitude  != null ? Number(p.Latitude)  : null,
  Longitude:  p.Longitude != null ? Number(p.Longitude) : null,
}));

  // 3) Enviar como text/plain (request simple, sin preflight)
  try {
    await fetch(WEB_APP_URL, {
      method: 'POST',
      mode: 'no-cors', // no podrás leer la respuesta, pero se insertará
      headers: { 'Content-Type': 'text/plain;charset=utf-8' },
      body: JSON.stringify(mapped)
    });
    alert(`Enviados ${mapped.length} registro(s) a Google Sheets (pestaña "MX").`);
  } catch (err) {
    console.error(err);
    alert('Error al enviar: ' + err.message);
  }
}




</script>
<script src="modules/tomtom.js"></script>
<script src="modules/city-elements.js"></script>
<script src="modules/sources.js"></script>
<script src="modules/kmz.js"></script>
<script src="modules/xls.js"></script>
<script src="modules/polygons.js"></script>
<script src="modules/notepad.js"></script>
<script src="modules/kmz-url.js"></script>
<script src="modules/mkts.js"></script>
<script src="modules/portfolio.js"></script>
<script src="modules/research.js"></script>


</script>
</body>
</html>

